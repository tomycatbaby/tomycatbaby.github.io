<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm]]></title>
    <url>%2F2019%2F04%2F23%2Fjvm%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JVM日记(一)]]></title>
    <url>%2F2019%2F04%2F17%2FJVM1%2F</url>
    <content type="text"><![CDATA[Java虚拟机第一篇熟读《深入理解java虚拟机》，将自己的所学所感记录下来 运行时数据区根据java虚拟机规范，JVM在执行程序时会将它所管理的内存划分为5大块数据区域，分为叫做方法区，堆，虚拟机栈，本地方法栈，程序计数器。方法区和堆都是所有线程共享的数据区，其余是线程隔离的数据区 1.虚拟机栈和本地方法栈虚拟机栈是线程隔离的数据区，理所当然它的生命周期随着线程的创建而产生，线程的销毁而终止。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧(stackframe)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到完成就是一个栈帧在虚拟机栈中入栈到出栈的过程。 大多数程序员所认知的堆和栈就是JVM的全部，而所指的栈就是虚拟机栈了，或者可以说是虚拟机栈的局部变量表部分。局部变量表存放了编译器可知的各种数据类型（java的8大基本数据类型），对象引用类型（它不等同于对象本身，可能是一个指向对象的指针或者是指向一个代表对象的句柄或其他于此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用两个局部变量空间，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成匹配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在java虚拟机规范中，对这个区域定义了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展。如果扩展时无法申请到足够的内存，就会抛出抛出OutOfMemoryError异常。 本地方法栈和虚拟机栈所发挥的作用是非常相似的，他们之间的区别是本地方法栈是为native方法服务的。 2.程序计数器程序计数器是一块较小的内存空间，由线程自身维护，我们可以将它看作是当前线程所执行的字节码的行号指示器。由于Java的多线程实际上是由线程轮流切换并分配处理器时间片来实现的，只是切换很快就让人以为是并发的。因此，为了线程切换后能够回到原来的位置，每条线程都需要有一个独立的程序计数器。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器值则为空。此内存区域是java虚拟机规范中唯一一个不会存在OutOfMemoryError。 3.Java堆Java堆的唯一目的是分配对象实例，几乎所有的对象实例都在这里分配内存，java规范的定义是：所有对象实例和数组都在堆上分配内存，但是随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些变化。 4.方法区方法区存放的是已被虚拟机加载的类信息，常量，静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做非堆，目的是与堆区分开来。对于习惯在Hotspot虚拟机上开发、部署程序的人来说，很多人愿意把方法区称为“永久代”，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已，便于HotSpot收集器管理这部分内存。 5.运行时常量池运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池对于Class文件常量池的另一个重要特性是具备动态特性，Java语言并不要求常量只会在编译期生成，也就是并非预置入Class文件中常量池的内容才能进入方法区常量池，运行期间的例子就是String的intern()方法 6.直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分的频繁使用也会导致OutOfMemoryError。在jdk1.4中加入了NIO（NewInput/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场合中显著提升性能，因为避免了在Java堆和Native堆中来回复制数据。 垃圾收集怎样判断对象yisi已死，回收它的内存？ ###1.引用计数算法给对象添加一个引用计数器，当有一个引用时+1，引用失效就-1.优点：实现简单，判断效率高，在大部分情况下是一个不错的算法，著名的应用案列有微软公司的COM技术，Python语言，使用ActionScript3的FlashPlayer等。缺点：很难解决对象的相互循环引用问题。 2.可达性分析算法基本思路：通过一系列的称为“GCRoots”的对象作为起始点，从这些节点往下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象无用。在Java语言中，可作为GC Roots的对象包括下面几种：1）、虚拟机栈中引用的对象2）方法区中类静态变量属性引用的对象3）方法区中常量的引用对象4）本地方法栈中JNI引用的对象 3.再谈引用无论是那种算法判断存活都与“引用”相关，所以为了将引用定义的更加清晰，以便于内存空间的管理，Java将引用定义了4种，强应用，软引用，弱引用，虚引用。这4种引用强度依次减弱 强应用(Strong Reference) 软引用(Soft Reference) 弱引用(Weak Reference) 虚引用(Phantom Reference) 强引用强应用就是代码中普遍存在的写法。 1Object o = new Object(); 软引用软引用就是用来描述一些还有用但并非必须的对象，Java提供了SoftReference类来实现软引用 123Object o = new Object();SoftReference&lt;Object&gt; sr = new SoftReference&lt;&gt;(o);Object object = sr.get(); 弱引用弱引用也是用来描述非必须对象的，它的引用强度更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，Java提供了WeakReference类来实现若引用。使用方法和软引用一致。 虚引用它是最弱的一种引用，它的存在不会影响对象的回收，也无法使用它来获取对象的实例，它存在的唯一目的是在与它关联的对象实例被回收的时候收到一个系统通知 回收方法区永久代的垃圾回收主要有两个方面：废弃常量和无用的类。 废弃常量以常量池的字面量为例，假如&quot;abc&quot;字符串已经存在于常量池了，但是在当前系统中没有一个地方引用了这个常量，如果发生内存回收且有必要的话他就会被回收。 无用的类判断无用的类要同时满足以下3个条件 该类所有的实例都已经被回收，也就是Java堆中不存在该类的实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。满足这些条件就有可能被虚拟机回收。 Java分代收集###1.Java年轻代和年老代 年轻代分为一个Eden区和两个survivor区（分别叫做from和to），比例一般为Eden：survivor=8:1，新new的对象都是分配在Eden区中（一些大对象特殊处理），经过第一次GC过后，如果对象依然被引用，那么就会移动到survivor区，对象在survivor区每多熬过一次MonitorGC，年龄就会增加一岁，当年龄达到一定时，会被移动到年老代中（Old区）。年轻代的对象大部分都是朝生夕死的，所以GC采用的是复制算法，复制算法就是将内存分为两块，一块用完了就将活着的对象移到另一块上面去，好处是不会产生内存碎片，缺点是会造成一半的内存浪费。 年老代：Old区当年老代被塞满之后就会触发Full GC，非常耗时，Old区GC算法为标记-清除或者标记-整理算法。标记-清除算法就是将内存还存活的对象标记，然后清除没有标记的对象，它存在两个问题，一是效率问题，标记和清除效率都不高，而是空间问题，清除之后会造成大量的空间碎片，就使得如果有比较大的对象没有连续空间分配就会再次触发GC。标记-整理算法和标记-清除算法的不同就是，所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 堆中分配很大的对象所谓大对象，是指需要大量连续内存空间的Java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的FullGC后,跟着来一次带压缩的 System.gc()方法的调用此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 入门第一篇]]></title>
    <url>%2F2018%2F10%2F28%2Fspringboot%2F</url>
    <content type="text"><![CDATA[很久没有学习Java开发相关知识了，由于现在的工作是Android开发，所以接触Android的东西很多，但是我还是对Java后台情有独钟，明年准备跳槽回到Java开发的工作，现在开始从这个比较流行的技术Spring Boot开始吧。Spring Boot原以为只是一个J2EE框架，其实不是，它应该是一种微服务框架，通俗的讲Spring Boot就是将我们Spring的开发工作简化了，使开发人员不在对配置文件浪费时间了。 入门第一天构建maven项目1、访问http://start.spring.io/ ,Spring提供自动构建demo项目，可以选择利用maven或者gradle构建项目，我选择的是maven2、maven项目开发结构一般是 src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 至此一个项目就可以跑起来了 引入Web模块1、添加web依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 2、编写一个controller1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;Hello World&quot;; &#125;&#125; @RestController注解作用是输出json格式数据3、现在运行项目，打开浏览器，输入http://localhost:8080/hello ,就可以看到你的输出了 Spring Boot单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数中1出现的次数]]></title>
    <url>%2F2018%2F04%2F17%2FtimesOfInteger%2F</url>
    <content type="text"><![CDATA[求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数 思路 按照数学的排列组合思路来解，数字1位于不同的位置，共有多少种排列，包括重复的排列。1、首先拿到一个整数，有m位，数字首位为s，则0~99..99（m-1个9）这个区间1出现的次数是sum=(m-1)*10^(m-2)（1的重复排列）；2、接下来count=s*sum(以2345为例，m为4，0~999区间1出现的次数为1的重复排列3*10*10=300，count=2*300=600)，统计的是后m-1位中1的重复排列与首位排列相乘；3、后面如果首位s大于1，就加上10^(m-1)(以2345例子就加上1000，count=600+1000=1600)； s等于1，就加上划去首位1的数再加上1（以1345例子看就是345+1，count+=346）4、接下来就是递归了，我就不赘述了，看代码。 详细代码 12345678910111213141516171819202122232425262728import java.util.HashMap;import java.util.Map;public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; if(n==0) return 0; else if(n&lt;10) return 1; int count = 0; int length = test(n)-1;//长度减一 int divisor = (int) Math.pow(10,length);//除数 int y = n%divisor;//余数 int l = n/divisor;//数字首位 int sum = (int)(length*Math.pow(10,length-1)); count = l*sum; if(l&gt;1) count+=divisor; else if(l==1) count=count+y+1; return count+NumberOf1Between1AndN_Solution(y); &#125; public int test(int n)&#123; String str = String.valueOf(n); char[]chars = str.toCharArray(); return chars.length; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之NexT主题搭建博客踩过的坑]]></title>
    <url>%2F2018%2F04%2F01%2Fnext%2F</url>
    <content type="text"><![CDATA[hexo+github搭建博客，自己也是拾前人牙慧，花了一天时间解决各种问题，本来很简单的问题也是在摸索中花费了大量时间，想起来就很搞笑，不过到底是解决了，好了，想要去看比较详细的过程就去: VOLC这个博客吧，写的够详细了，下面写我踩过的坑吧。 遇到的问题1.图标问题新版的hexo不需要在menu_icons中用key-value方式为menu添加图标，在菜单项menu（名称和链接）加 || FontAwesome icon的name 123456789101112menu: home: / ||home categories: /categories ||th archives: /archives ||archive tags: /tags ||tags message: /message ||external-link about: /about ||user #commonweal: /404.html# Enable/Disable menu icons.menu_icons: enable: true 2.头像问题在blog/source文件夹下新建img文件夹，将你的头像图片放进去，在站点文件_config.yml中修改 12# 设置头像avatar: img/hg.jpeg 3.在博文中添加图片1.把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true2.在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件3 最后在xxxx.md中想引入图片时，先把图片复制到source/_posts/xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) 4.本地项目托管到github首先在你的github中new一个新的代码仓库，name：{your blog’s name}.github.io 修改站点文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:tomycatbaby/tomycatbaby.github.io.git branch: master 验证是否能否连接到github1$ ssh -T git@github.com 成功后1Hi zhangsan! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 上传代码 中间会输入github密码 1hexo -d 成功后就可以用 http://tomycatbaby.github.io 访问了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
