<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>关于Handler</title>
      <link href="/2019/07/03/handler/"/>
      <url>/2019/07/03/handler/</url>
      
        <content type="html"><![CDATA[<h2 id="1、关于handler消息机制有哪些重要关键的类？"><a href="#1、关于handler消息机制有哪些重要关键的类？" class="headerlink" title="1、关于handler消息机制有哪些重要关键的类？"></a>1、关于handler消息机制有哪些重要关键的类？</h2><p>Handler，Message，MessageQueue，Looper<br><code>Handler</code>是发送的处理消息的类，发送消息的方法都是final修饰的，handleMessage方法是空方法，我们必须要去重写它<br><code>Message</code>是消息体，包括what，arg1，arg2,obj这4个发送消息必须显示赋予的，然后Message类自己有一个消息池，它的使命是减少重复new Message对象，浪费资源。<br>最后要提到的关键的属性就是when，target，callback这几个属性是干嘛的后面再讲<br><a id="more"></a><br><code>Looper</code>，消息循环器，作用是从MessageQueue中取出消息体，然后去处理<br><code>MessageQueue</code>，消息队列，存放消息体的数据结构，作用是存放消息体，阻塞Looper消息循环等</p><h2 id="2、handler发送消息的方式"><a href="#2、handler发送消息的方式" class="headerlink" title="2、handler发送消息的方式"></a>2、handler发送消息的方式</h2><h3 id="两种方式：post和send"><a href="#两种方式：post和send" class="headerlink" title="两种方式：post和send"></a>两种方式：<code>post</code>和<code>send</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handler.obtainMessage().sendToTarget();</span><br><span class="line">handler.post();//直接执行</span><br><span class="line">handler.postAtTime()//某个时间点执行</span><br><span class="line">handler.postDelayed()//延迟多少事件执行</span><br><span class="line">handler.postAtFrontOfQueue()//放到消息队列前面执行</span><br><span class="line">handler.sendMessage();</span><br><span class="line">handler.sendMessageAtTime()//某个时间点执行</span><br><span class="line">handler.sendEmptyMessage()//向消息队列中发送一个只带what不带其他obj的消息</span><br><span class="line">Message.obtain().sendToTarget();//Message.obtain()是建议使用的生成Message对象的方式，Message类维护了一个消息池，复用Message对象</span><br></pre></td></tr></table></figure><p>上面没有包括所有的发送方式，但是所有的发送方式都会走到Handler的两个方法：</p><blockquote><p>1.sendMessageAtTime(Message msg, long uptimeMillis)<br>2.sendMessageAtFrontOfQueue(Message msg)</p></blockquote><p>然后这两个方法殊途同归都会走到<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>这个方法，区别是方法1的<code>uptimeMillis</code>参数是<code>SystemClock.uptimeMillis() + delayMillis</code>，<code>delayMillis</code>就是提供的延时时间，没有值或者小于0默认为0，方法2的uptimeMillis是0。<br>ps:</p><blockquote><p>SystemClock.uptimeMillis()  从开机到现在的毫秒数（手机睡眠的时间不包括在内）；<br>System.currentTimeMillis()  从1970年1月1日 UTC到现在的毫秒数；这个值是不准的，可以被修改。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;//将消息体的target绑定为当前的handler</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">    //设置消息体是不是异步，生成消息体时如果没有设置那一定就是false，如果要设置调用消息体的setAsynchronous()设置</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是那种方式，都直接或间接需要一个handler对象，<code>Handler</code>类的构造函数需要初始化4个属性<code>mLooper</code>，<code>mQueue</code>，<code>mCallback</code>，<code>mAsynchronous</code>，分别讲下这4个怎么赋值的，先讲下Handler的构造函数，明面上的有三个，撸到底就两个<code>@hide</code>的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1、//调用这个构造函数的前提是传入了looper对象，或者looper和callback一起传入，async默认为false</span><br><span class="line">    public Handler(Looper looper, Callback callback, boolean async) &#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;//用Looper循环器的消息队列去初始化handler的消息队列</span><br><span class="line">        mCallback = callback;//没传就为null</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line">2、//调用这个构造函数的前提是传入了callback对象，或者什么都没传，async默认为false</span><br><span class="line">    public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class="line">                        + &quot; that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>从上面我们可以看到显式new出来的方式都是同步的，异步的怎么生成？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler.createAsync(@NonNull Looper looper, @NonNull Callback callback)</span><br></pre></td></tr></table></figure></p><p>就是上面的方法了，它是一个静态的，方法体内默认async为true。接下来分析这几个属性：<br>1、<code>Looper</code>:上面两种方式，一种是自己传进去，另一种是自己获取，也就是<code>Looper.myLooper()</code>重点说下第二种，Looper类中维护了一个<code>ThreadLocal</code>，使用第二种方式获取也就是从当前本地线程副本中去获取Looper，在不同的线程中这个副本是不一致的，所以说在新开启的线程中，这个副本是<code>get</code>到的是<code>null</code>。所以如果handler初始化时如果没有传入looper的话，那就是第二种Handler的构造函数，它会默认调用当前线程绑定的Looper，可以看到如果获取的<code>looper</code>为<code>null</code>，会抛出运行时异常，所以你知道了吧，为什么在非主线程中使用新建使用handler的话，必须先调用<code>Looper.prepare()</code>方法<br>2、<code>MessageQueue</code>的初始化都是由Looper中的消息队列来完成的，Looper中的属性是在构造器中初始化的，而MessageQueue类的构造器是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要传入一个是否允许停止的标志位，可以看到还使用了一个<code>nativeInit()</code>,这个是一个native方法。<code>MessageQueue</code>中有很多native方法，包括初始消息队列，销毁消息队列，唤醒消息队列，都是利用了native层方法，在native层也有一个消息队列。<br>3、<code>Callback</code>，Handler中封装的一个接口，里面只有一个<code>handleMessage</code>方法，它的执行顺序在Handler的handlerMessage空方法之前，具体可以看loop循环时分发消息调用handler的消息分发方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//handler处理消息分发的唯一的入口</span><br><span class="line">    public void dispatchMessage(Message msg) &#123;</span><br><span class="line">        if (msg.callback != null) &#123;</span><br><span class="line">            handleCallback(msg);// =&gt;msg.callback.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mCallback != null) &#123;</span><br><span class="line">            //handler重写的handleMessage执行顺序在callabck的handleMessage之后，也就是callback不为null，且callback的handleMessage返回true，这个消息就被消化掉了，不会再执行Handler重写的handleMessage</span><br><span class="line">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>4、<code>async</code>异步属性，这个属性唯一在handler中使用的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这里是消息体入消息队列的唯一入口</span><br><span class="line">    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">        msg.target = this;</span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);//为入队的消息设置为异步消息</span><br><span class="line">        &#125;</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="3、我们知道handler可以发送延时消息，那它是怎样实现延时处理的？"><a href="#3、我们知道handler可以发送延时消息，那它是怎样实现延时处理的？" class="headerlink" title="3、我们知道handler可以发送延时消息，那它是怎样实现延时处理的？"></a>3、我们知道handler可以发送延时消息，那它是怎样实现延时处理的？</h2><p> 提到延时，可以想起来在每个消息体入消息队列之前，都会初始化when属性，这个属性是一个时间点，在loop方法中会去从消息队列中取消息。我们来看消息怎样取出来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> public static void loop() &#123;</span><br><span class="line">        //死循环一直跑</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //从messageQueue中取出消息,如果是UI主线程的Looper，这里就有可能阻塞，因为UI主线程的Looper是必须一直跑起来的，很多其他的消息行为，如启动Activity之类的都是在这个Looper中接收处理的，而如果是其他的另开的线程，使用了Looper.prepare和Looper.loop，是定义了自己的线程循环器，根据源码上来看，这个定义的looper是可以停止的，也就是说，当消息队列中没有消息之后，这个消息队列返回的msg就为空</span><br><span class="line">然后loop方法就会return。</span><br><span class="line">            ......</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            .....</span><br><span class="line">            try &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);//去调用消息队列绑定的handler去执行消息分发</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            //消息体处理完之后进行销毁</span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 <code>Message msg = queue.next()</code>这一行代码是有可能阻塞的，当时间还没到我们预设的时间，消息队列就没被唤醒，也就取不出消息体，消息就是这样实现延时的。我们再看下next方法,去从中找出它阻塞的证据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    // Return here if the message loop has already quit and been disposed.</span><br><span class="line">    // This can happen if the application tries to restart a looper after quit</span><br><span class="line">    // which is not supported.</span><br><span class="line">    final long ptr = mPtr;</span><br><span class="line">    if (ptr == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">    int nextPollTimeoutMillis = 0;//字面意思是取出下一个消息体的阻塞时间，用于确定消息队列应处于出队状态还是等待状态,-1表示等待状态，0表示返回，&gt;0表示阻塞多少毫秒</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);//这里就是实现阻塞的地方了，C方法</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // Try to retrieve the next message.  Return if found.</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = null;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            //target就是处理的handler，如果取到的消息不为null，但是handler为null，就遗弃这个消息</span><br><span class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg =msg.next;</span><br><span class="line">                    //这两句是将当前指向的msg向后移直到msg不为null且当前的消息不是异步消息</span><br><span class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    //表示当前取出的消息还没到预定执行的时间点，设置一个超时时间去唤醒</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 取出一个消息体</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    if (prevMsg != null) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //取出的msg为null，然后将这个参数置为-1，然后去阻塞</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process the quit message now that all pending messages have been handled.</span><br><span class="line">            //已处理所有待处理的消息</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();//截断这个消息队列，在调用了quit()方法后会调用</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        nextPollTimeoutMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4、在子线程使用handler要注意什么？"><a href="#4、在子线程使用handler要注意什么？" class="headerlink" title="4、在子线程使用handler要注意什么？"></a>4、在子线程使用handler要注意什么？</h2><p>新开子线程的Looper的ThreadLocal中没有绑定looper，所以必须先调用Looper.prepare()方法先初始化Looper和MessageQueue，或者在Handler构造器中传入已经初始化好的looper，比如<code>Handler h = new MyHandler(Looper.getMainLooper())</code>;这种方式，而如果要绑定自己线程的循环器和消息队列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare();</span><br><span class="line">Handler h = new Handler();//初始化handler必须在prepare后面</span><br><span class="line">h.sendEmptyMessage(1);</span><br><span class="line">//sendmessage必须在loop()前面，原因是loop()是个死循环，它没有销毁之前，后面的语句都不会执行</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android标签</title>
      <link href="/2019/06/14/label/"/>
      <url>/2019/06/14/label/</url>
      
        <content type="html"><![CDATA[<h2 id="ViewStub-懒加载"><a href="#ViewStub-懒加载" class="headerlink" title="ViewStub 懒加载"></a>ViewStub 懒加载</h2><p>最开始接触<code>ViewStub</code>是从<code>DecorView</code>中认识的，都知道DecorView是顶级的View，它是一个线性布局，它有两个子View：<code>ViewStub</code>和<code>FrameLayout</code>,帧布局中包括一个<code>FitWindowsLinearLayout</code>布局，<code>FitWindowsLinearLayout</code>包含<code>ViewStubCompat</code>和<code>ContentFrameLayout</code>，而我们使用setContentView放进去的布局文件就是放在ContentFrameLayout这个布局之中。而我们最开始就接受到的知识是DecorView是两个部分组成的，一个是titleView，另一个就是<code>ContentView</code>（可以用findViewById(<code>android.R.id.content</code>)获取）。<br><a id="more"></a><br><img src="/2019/06/14/label/label.png" alt="你想输入的替代文字"><br>ViewStub也是继承自View，它使用的是惰性加载的方式，也就是即使它已经包含于布局文件中，但是不主动加载，它就是为空的。ViewStub一般用于需要展示另外的一个效果，如网络加载失败的页面显示。</p><h3 id="ViewStub的加载原理"><a href="#ViewStub的加载原理" class="headerlink" title="ViewStub的加载原理"></a>ViewStub的加载原理</h3><p><code>ViewStub</code>只能加载一次，重复加载会导致异常，这是因为ViewStub只要加载一次自身就会被移除，并把自身所包含的内容传递给父布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ViewStub</span><br><span class="line">        android:id=&quot;@+id/vs&quot;</span><br><span class="line">        android:layout=&quot;@layout/activity_detail&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>调用的ViewStub的<code>inflate()</code>方法就会加载布局，还有一种加载它的方法，在它的<code>setVisibility</code>方法的源码中可以看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void setVisibility(int visibility) &#123;</span><br><span class="line">    if (mInflatedViewRef != null) &#123;</span><br><span class="line">        View view = mInflatedViewRef.get();</span><br><span class="line">        if (view != null) &#123;</span><br><span class="line">            view.setVisibility(visibility);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;setVisibility called on un-referenced view&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.setVisibility(visibility);</span><br><span class="line">        if (visibility == VISIBLE || visibility == INVISIBLE) &#123;</span><br><span class="line">            inflate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你设置visibility为<code>VISIBLE</code>或<code>INVISIBLE</code>就会调用inflate()去加载</p><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p>include的用法也很简单，它的出现提高了布局的可重用性，使得更方便控制管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;include</span><br><span class="line">    layout=&quot;@layout/app_bar_main&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>使用include可能遇到的坑：<br>1、<include>标签当中可以重写layout的所有属性，在里面覆写的layout属性会覆盖掉实际layout（如上就是app_bar_main）布局的layout属性），另外需要注意的是如果要覆写layout属性的话，必须要覆写<code>layout_width</code>和<code>layout_height</code>，Android Studio一般也会提示。<br>2、一个布局文件中如果有多个<include>标签需要设置id才能找到对应的子控件，否则只能找到第一个include的布局文件及控件<br>3、如果你在<include>和include的根布局文件都设置了id，需要保持一致，否则可能获取不到根布局对象。</include></include></include></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p><merge>标签是配和<include>标签使用的，作为include的根布局标签，意义是帮助include标签去除一层多余的ViewGroup，具体很简单就不用多说，想想就明白了。<br>使用merge的注意事项：<br>1、根布局是<code>FrameLayout</code>且不需要设置<code>background</code>或<code>padding</code>等属性，可以用merge标签代替，因为<code>setContentView</code>就是加载到帧布局之中的。<br>2、因为merge不是View，所以在通过<code>LayoutInflate.inflate()</code>方法渲染的时候，第二个参数必须指定一个<code>父容器</code>，第三个参数必须为<code>true</code>，由于merge不是View，所以对merge标签的所有设置都是无效的。</include></merge></p><h2 id="附录：一个求Activity最大层级的算法"><a href="#附录：一个求Activity最大层级的算法" class="headerlink" title="附录：一个求Activity最大层级的算法"></a>附录：一个求Activity最大层级的算法</h2><p>在网上看到过一个递归版本的这种算法，那既然递归版本的有了，就来一个非递归版本的。其实这个算法可以看做是一颗树（因为View的层级就是一棵View树），那其实就是利用树的层次遍历，算出最深的节点，树的层次遍历怎么实现也就很简单拉，就是把每一层从左到右依次放入一个队列中，从队列头部取出，然后将它的子节点放到队列末尾，一直循环执行下去知道队列为空。那我们并不要这个层次遍历输出的结果，我们只需要最大深度该怎么实现，难搞啊。<br>不慌，问题不大，我们可以在一层子节点的队列尾部加上一个标志，等到队列的同级的节点都出了队列的时候，就到了这个标志，就意味着一层已经遍历完了，然后再将这个标志移到队列的尾部，继续执行，那不就行了，但是要注意，如果没有下一层，那么一直移动就会造成死循环，所以排除掉这种情况。好，下面上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void findDeep() &#123;</span><br><span class="line">    ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();</span><br><span class="line">    //TickView一个自定义View，用来当做标志位</span><br><span class="line">    TickView tickView = new TickView(getApplicationContext());</span><br><span class="line">    Queue&lt;View&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(viewGroup);</span><br><span class="line">    queue.add(tickView);</span><br><span class="line">    int deep = 0;</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        if (queue.peek() instanceof ViewGroup) &#123;</span><br><span class="line">            viewGroup = (ViewGroup) queue.poll();</span><br><span class="line">            int count = viewGroup.getChildCount();</span><br><span class="line">            if (count &gt; 0) &#123;</span><br><span class="line">                for (int i=0;i&lt;count;i++)&#123;</span><br><span class="line">                    if (viewGroup.getChildAt(i) instanceof ViewGroup)&#123;</span><br><span class="line">                        queue.offer(viewGroup.getChildAt(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (queue.peek() instanceof TickView) &#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">            deep++;</span><br><span class="line">            if (!queue.isEmpty())&#123;</span><br><span class="line">                queue.offer(tickView);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, &quot;findDeep: &quot;+deep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android内存管理之内存抖动、内存泄露、内存溢出</title>
      <link href="/2019/06/02/memory/"/>
      <url>/2019/06/02/memory/</url>
      
        <content type="html"><![CDATA[<h1 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h1><p>内存抖动的现象就是UI界面的卡顿，出现的原因就是年轻代的频繁GC。JVM的每次年轻代GC都会触发“全世界的暂停（stop-the-world）”，也就会导致卡顿。避免出现内存抖动的几点建议：<br>1、不要在循环体内创建对象，将创建对象放到循环体外，在循环体内重用一个对象。<br>2、自定义View的<code>onDraw()</code>，<code>onMeasure()</code>方法会多次调用，所以尽量不要在里面创建对象。<br>3、当需要使用大量的Bitmap的时候，应该将他们缓存到数组中使用。<br>4、同理，对于有复用的对象，可以用对象池将它缓存起来。<br><a id="more"></a></p><h1 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h1><p>内存溢出意思就是为对象申请不到足够的内存空间了，导致OOM。内存溢出导致的原因可能是内存泄露，也有可能是JVM分配的内存真的不够使用了。在Android手机上，系统为程序最初分配的内存都是一致的，所以开发者尽量不要占用太多的内存空间，没有使用的对象及时置为null。一般情况这种场景是不会出现的，程序员一般只需要关注内存抖动和内存泄露。</p><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>在Android手机上，内存是很珍贵的，系统为每个应用分配了固定的内存大小，如果申请不到足够的内存空间，就直接导致内存溢出。以前并没有内存泄露的概念，单纯的以为JVM会管理好所有的内存空间，并不需要开发者操心，但事实上不是。内存泄露的根本原因是<code>一个长生命周期的对象持有了一个短生命周期的对象的引用</code>。下面我们来看下Android上面的有哪些内存泄露的风险。</p><blockquote><ul><li>单例模式导致内存泄露，静态对象的生命周期和应用程序一样长，如果持有一个短生命周期如Activity的context就会导致activity无法被回收，所以应该使用getApplicationContext()进行初始化。</li><li>内部Handler如果持有了Activity的强引用，而handler执行没有完成，activity就已经调用onDestory了，就会导致activity无法被回收。</li><li>非静态内部类默认持有外部类对象引用。所以导致外部类销毁时仍然持有外部类引用，导致外部类无法被回收。</li><li>未去注册，如广播，服务，注册或者启动之后必须要去注册</li><li>资源对象未及时释放，如Cursor、Stream、Socket，Bitmap等在使用后要及时关闭。</li><li>集合中的对象要及时clear。</li></ul></blockquote><p>Android Studio会对代码中可能出现内存泄露的地方会给出提示，能够避免很多常见的内存泄露。<br>对于第二种情况的内存泄露，我们一般是使用静态内部类+弱引用的方式去解决，handler不持有activity引用，而是通过弱引用去获得一个弱引用对象。<br>第三种情况有很多例子场景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//线程匿名内部类</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">new AsyncTask&lt;Void, Void, Void&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Void doInBackground(Void... params) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.execute();</span><br><span class="line">//线程写成静态内部类</span><br><span class="line">private static class MyThread implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(20000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android关于内存的最佳实践</p><blockquote><ul><li>Enum非常占用内存，因为枚举类型的每个属性值都是Object，每声明一个值都会创建内存以便能引用到这个对象，Android中使用@IntDef、@StringDef来替代枚举类型的使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 的 Enum 的实质是特殊单例的静态成员变量</span><br><span class="line">Enum 可以在编写器，编译器做到各种静态检查防呆</span><br><span class="line">Enum 在运行期，所有枚举类作为单例，全部加载到内存中</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>内存泄露是非常容易出现的，上面只是一些大多数场景，还有很多需要注意的地方，特别是一些框架、组件这样的内存泄露很容易忽视。查找内存泄露的方式也很多，如<code>LeakCanary</code>，还有<code>Android Studio3.0</code>自带的<br><code>Android Profiler</code>，熟练使用这些工具能够快速的帮助自己定位内存泄露，提高程序的性能。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android有哪些处理耗时任务的方式</title>
      <link href="/2019/05/09/androidThread/"/>
      <url>/2019/05/09/androidThread/</url>
      
        <content type="html"><![CDATA[<h3 id="1、IntentService"><a href="#1、IntentService" class="headerlink" title="1、IntentService"></a>1、IntentService</h3><p>IntentService是继承并处理异步请求的一个类，在IntentService中有一个工作线程来处理耗时操作，启动方法和常规Service一样，不同的是它不需要我们手动控制或销毁，而且IntentService可以启动多次，而每一个耗时操作会以工作队列的方式在IntentService的<code>onHandleIntent</code>回调方法中执行，并且是串行执行，必须等待前一个执行完成后才会执行下一个。<br>看源码<code>IntentService</code>实际上就是内部实现了一个<code>Handler</code>，我们知道每启动一次service，如果这个service已经存在就会调用onStartCommand，否则就先执行onCreate方法，在<code>onStartCommand</code>方法中默认会调用onStart方法，IntentService的<code>onStart</code>方法源码如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在这个方法中会向自己的handler提交一条消息，然后我们看它的handler源码的handleMessage方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到会调用<code>onHandleIntent</code>，然后执行完之后自动调用<code>stopself</code>。这就是我们使用<code>IntentService</code>默认必须实现它的<code>onHandleIntent</code>方法，而且它执行完成后会自动销毁的原因了。</p><h3 id="2、Activity中的runOnUiThread（Runnable-runnable）"><a href="#2、Activity中的runOnUiThread（Runnable-runnable）" class="headerlink" title="2、Activity中的runOnUiThread（Runnable runnable）"></a>2、Activity中的runOnUiThread（Runnable runnable）</h3><p>runOnUiThread是Activity中独有的方法，可以实现与UI主线程的通信，那它是怎么通信的呢？<br>首先看这个方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void runOnUiThread(Runnable action) &#123;</span><br><span class="line">        if (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">            mHandler.post(action);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            action.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码什么意思呢？就是当前的线程如果不是UI线程，就向handler提交一个任务，否则就直接调用run方法。所以这个方法就是在activity开启耗时线程执行完成后去提交UI修改。</p><h3 id="3、View-post或postDelayed"><a href="#3、View-post或postDelayed" class="headerlink" title="3、View.post或postDelayed"></a>3、View.post或postDelayed</h3><p>这个方法也是和runOnUiThread类似的，可以实现与UI主线程的通信，不同的是它提交到的是<code>HandlerActionQueue</code>去解决，而且它可以延时执行。</p><h3 id="4、AsyncTask"><a href="#4、AsyncTask" class="headerlink" title="4、AsyncTask"></a>4、AsyncTask</h3><p>AsyncTask顾名思义就是Android的异步任务，同样在异步任务中也可以执行耗时操作并更新UI，用过异步任务的都知道AsyncTask是一个抽象类，使用它必须继承它并重写它的方法，必须实现它的<code>doInBackground</code>方法，但是一般情况下我们都需要使用它提供的更多的功能，也就是继承<code>AsyncTask&lt;Params,Progress,Result&gt;</code>。这里面三个参数代表什么意思呢？第一个<code>Params</code>表示启动任务时你需要携带给它的参数类型，也就是调用execute方法向里面传递的参数，后面讨论它传递到哪里去了，第二个<code>Progress</code>表示后台任务执行中返回进度值的类型，第三个<code>Result</code>表示后台任务执行完成后返回结果的类型。</p><p>我们一般会重写以下4个方法：</p><ul><li>doInBackground：必须重写的方法，异步执行后台线程要完成的任务,耗时操作将在此方法中完成</li><li>onPreExecute:执行后台耗时操作前被调用,通常用于进行初始化操作.</li><li>onPostExecute:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新.</li><li>onProgressUpdate:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度.<br>这4个方法的调用顺序是怎样的呢？我们从调用execute方法开始看：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">    return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br><span class="line">@MainThread</span><br><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">        Params... params) &#123;</span><br><span class="line">  ...</span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">private final WorkerRunnable&lt;Params, Result&gt; mWorker;</span><br><span class="line"></span><br><span class="line">private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;</span><br><span class="line">    Params[] mParams;</span><br><span class="line">&#125;</span><br><span class="line">private final FutureTask&lt;Result&gt; mFuture;</span><br></pre></td></tr></table></figure></li></ul><p>我们可以看到首先是<code>onPreExecute()</code>最先调用的，所以我们在执行耗时操作前先使用它初始化，然后我们看到它将execute传递进来的params数组赋给了一个数组，mWorker在构造函数中初始化，然后执行<code>exec.execute(mFuture)</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//一个双端队列，存着工作任务</span><br><span class="line">final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">Runnable mActive;</span><br><span class="line">public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">        mTasks.offer(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (mActive == null) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //从队列中取出下一个任务</span><br><span class="line">    protected synchronized void scheduleNext() &#123;</span><br><span class="line">        if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>我们看这个execute方法，它的参数是<code>FutureTask</code>类型的Runnable，传入的mFuture会在一个新的工作任务中执行，然后调用<code>scheduleNext()</code>执行下一个任务。所以现在就到了<code>FutureTask.run</code>方法了，<code>mFuture</code>是在谁初始化的呢？mFuture.run方法会调用什么呢？我们从构造函数中可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//异步任务的构造方法，默认调用</span><br><span class="line">public AsyncTask(@Nullable Looper callbackLooper) &#123;</span><br><span class="line">    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()</span><br><span class="line">        : new Handler(callbackLooper);</span><br><span class="line">    //WorkerRunnable的初始化</span><br><span class="line">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        public Result call() throws Exception &#123;</span><br><span class="line">            mTaskInvoked.set(true);</span><br><span class="line">            Result result = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                //noinspection unchecked</span><br><span class="line">                result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125; catch (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(true);</span><br><span class="line">                throw tr;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //FutureTask任务的初始化</span><br><span class="line">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void done() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                postResultIfNotInvoked(get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                        e.getCause());</span><br><span class="line">            &#125; catch (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mFuture是mWorker这个参数去初始化的，关于FutureTask的知识可以去看<a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java并发编程：Callable、Future和FutureTask</a>。<br>所以最终调用的是<code>mWorker</code>的<code>call</code>方法，在<code>call</code>方法里面我们看到它调用了<code>doInBackground(mParams)</code>，而且传入了<code>mParams</code>数组,<code>doInBackground</code>方法的返回值就是<code>Result</code>类型，最后调用<code>postResult(Result result)</code>方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Result postResult(Result result) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这个方法是向它的handler提交了一条消息。<br>我们来看这个handler的消息处理方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case MESSAGE_POST_RESULT:</span><br><span class="line">            // There is only one result</span><br><span class="line">            result.mTask.finish(result.mData[0]);</span><br><span class="line">            break;</span><br><span class="line">        case MESSAGE_POST_PROGRESS:</span><br><span class="line">            result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到它只会处理两种消息，一种是异步任务执行完成，一种是在异步方法执行中调用，那我们接着看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">protected final void publishProgress(Progress... values) &#123;</span><br><span class="line">    if (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void finish(Result result) &#123;</span><br><span class="line">    if (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到执行完成后调用的finish方法，如果正常执行完成，调用的是<code>onPostExecute(result)</code>，所以我们说<code>onPostExecute</code>方法执行在<code>doInBackground</code>方法后，我们说在<code>doInBackground</code>方法中调用<code>publishProgress</code>方法，会调用<code>onProgressUpdate</code>方法，也可以从上面的源码中得出结论。</p><h3 id="5、HandlerThread"><a href="#5、HandlerThread" class="headerlink" title="5、HandlerThread"></a>5、HandlerThread</h3><p>一个Android封装的轻量级异步类。知道它的工作原理也就知道了它的优点，它是利用<code>Thread+Handler</code>实现的，它继承自Thread，使用它需要先创建一个HandlerThread实例，紧接着调用start将这个线程启动起来，它的run方法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    mTid = Process.myTid();</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();</span><br><span class="line">    Looper.loop();</span><br><span class="line">    mTid = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6、Handler"><a href="#6、Handler" class="headerlink" title="6、Handler"></a>6、Handler</h3><p>从上面所有的方式中我们都可以看到Handler的身影，所以说学习Android必须先学好Handler。<br>关于Handler的博客就太多了，可以看<a href="https://www.jianshu.com/p/b4d745c7ff7a" target="_blank" rel="noopener">Android Handler：手把手带你深入分析 Handler机制源码</a>,<a href="https://www.jianshu.com/p/e172a2d58905" target="_blank" rel="noopener">Android：这是一份Handler消息传递机制 的使用教程</a>,<a href="https://www.jianshu.com/p/f0b23ee5a922" target="_blank" rel="noopener">Android Handler：图文解析 Handler通信机制 的工作原理</a>,上面三篇从使用，到原理，到源码由浅入深仔细讲解了Handler机制。</p><p><code>问</code>：在线程中使用Handler时(除了Android主线程)必须把它放在<code>Looper.prepare()</code>和<code>Looper.loop()</code>之间。否则会抛出RuntimeException异常。但是为什么要这么做呢？<br><code>答</code>：通俗的讲Handler机制就是主线程中有一个无限循环，与UI主线程绑定起来，它会一直循环，拿到一个消息之后就会去主线程中去调用handleMessage方法。<br>其实就是Looper类和Handler类，Looper类封装了消息循环和消息队列，当你调用了Looper.prepare()之后，这个Looper就开始启用了，一般情况主线程在Application初始化的时候就已经自动创建一个Looper，因为一个线程就只能有一个Looper，所以在非主线程中先要调用Looper.prepare()先创建一个Looper。调用Looper.loop()之后就开始了从MessageQueue中取出消息的无限循环。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android事件分发机制</title>
      <link href="/2019/04/23/android/"/>
      <url>/2019/04/23/android/</url>
      
        <content type="html"><![CDATA[<p>View的事件分发机制是解决滑动冲突的基础。<br>首先要理解两个概念，<code>View</code>和<code>ViewGroup</code>，控件如<code>Button</code>，<code>TexiView</code>，<code>ImageView</code>等都继承自<code>View</code>父类，布局如<code>LinerLayout</code>，<code>RelativeLayout</code>等都继承自<code>ViewGroup</code>。那怎么理解这两个东西呢？我们可以将整个Activity页面看做一个容器，所有的控件（View）都装在这个容器（ViewGroup）里。</p><p>首先我们先说下结论，Android中Touch事件的传递绝对都是先到ViewGroup，然后在到View，所以无论点击了哪个控件都会先调用所在布局的<code>dispatchTouchEvent</code>方法，<br>如果没有被消费掉就会向下传递到控件的dispatchTouchEvent方法。<br><a id="more"></a><br>然后我们看以下三个核心方法：</p><blockquote><ul><li>public boolean dispatchTouchEvent(MotionEvent ev)<br>用来进行事件的分发。如果事件能够传递给当前的View，那么这个方法就一定会被调用，返回结果受当前View的onTouchEvent和下级的dispatchTouchEvent方法影响，表示是否消耗当前事件。</li><li>public boolean onInterceptTouchEvent(MotionEvent event)<br>在dispatchTouchEvent方法内部调用，这个方法表示是否拦截某个事件，这个方法存在于父级的View中，也就是一般重写在ViewGroup中</li><li>public boolean onTouchEvent(MotionEvent event)<br>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件</li></ul></blockquote><p>用一段伪代码来表示三种方法的关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev)&#123;</span><br><span class="line">    boolean comsume = false；</span><br><span class="line">    if(onInterceptTouchEvent(ev))&#123;</span><br><span class="line">        consume = onTouchEvent(ev);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    return consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当一个，<code>View</code>需要处理事件时，如果它设置了<code>OnTouchListener</code>，那么<code>OnTouchListener</code>中的<code>onTouch</code>方法被回调。这时事件如何处理还要看<code>onTouch</code>的返回值，如果返回<code>false</code>，则当前<code>View</code>的<code>onTouchEvent</code>方法会被调用；如果返回true，那么<code>onTouchEvent</code>方法将不会调用。由此可见，给View设置的<code>OnTouchListener</code>，其优先级比<code>onTouchEvent</code>要高。在<code>onTouchEvent</code>方法中，如果当前设置的有<code>onClickListener</code>，那么它的click方法会被调用，可以看出我们平时所用的<code>onClickListener</code>优先级最低，位于末端。<br>当一个点击事件产生后，它的传递过程遵循如下规则：<code>Activity</code>-&gt;<code>Window</code>-&gt;<code>View</code>,这里的View是<code>顶级View</code>，顶级View接收到事件后，会按照事件分发机制一步步向下分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的<code>onTouchEvent</code>将会被调用，以此类推。如果所有的元素都不处理这个事件，那么最终这个事件会被传递给<code>Activity</code>处理，调用<code>Activity</code>的<code>onTouchEvent</code>方法。<br>关于事件分发机制，这里有一些结论：<br>（1）同一事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕，事件序列会经历down事件，以及数量不定的move事件，最后以up事件结束；<br>（2）正常情况下，一个事件序列只能被一个View拦截消耗；<br>（3）某个View一旦决定拦截，那么这一个事件序列只能由它自己处理，并且它的<code>onInterceptTouchEvent</code>方法<br>不会再被调用<br>（4）某个<code>View</code>一旦开始处理事件，如果它不消耗<code>ACTION_DOWN</code>事件（<code>onTouchEvent</code>返回了<code>false</code>），那么同一事件序列的其他事件都不会再交给它处理，并且事件将重新交由它的父元素去处理，即调用父元素的<code>onTouchEvent</code>。<br>（5）如果<code>View</code>不消耗除了<code>ACTION_DOWN</code>的其他事件，那么这个点击事件会消失，此时父元素的<code>onTouchEvent</code>并不会被调用，并且当前<code>View</code>可以持续收到后续事件。并且这些消失的点击事件会交给<code>Activity</code>处理。<br>（6）<code>ViewGroup</code>默认不会拦截任何事件。<br>（7）<code>View</code>没有<code>onInterceptTouchEvent</code>方法，一旦有事件传递给它就会调用它的<code>onTouchEvent</code>方法。<br>（8）<code>View</code>的<code>onTouchEvent</code>默认都会消耗事件，除非它是不可点击的（<code>clickable</code>和<code>longClickable</code>同时为<code>false</code>，<code>View</code>的<code>longClickable</code>默认为<code>false</code>）。<br>（9）<code>View</code>的<code>enable</code>属性不影响<code>onTouchEvent</code>的默认返回值。<br>（10）onClick会发生的前提是当前View是可点击的，并且它收到了down和up事件。<br>（11）事件传递过程都是由外向内的，通过<code>requestDisallowInterceptTouchEvent</code>方法可以在子元素中干预父元素的事件分发过程，但是<code>ACTION_DOWN</code>事件除外。<br><code>mInputEventConsistencyVerifier</code>变量是调试用的，不用理会。<br><code>onFilterTouchEventForSecurity()</code>表示是否要分发该触摸事件，具体可以看里面的源码，主要看是否该View是否被屏蔽了。<br><code>intercepted</code>变量标志Group是否拦截Touch事件的传递，会调用ViewGroup的<code>onInterceptTouchEvent</code>方法进行判定。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM日记(一)</title>
      <link href="/2019/04/17/JVM1/"/>
      <url>/2019/04/17/JVM1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java虚拟机第一篇"><a href="#Java虚拟机第一篇" class="headerlink" title="Java虚拟机第一篇"></a>Java虚拟机第一篇</h1><p>熟读《深入理解java虚拟机》，将自己的所学所感记录下来</p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>根据java虚拟机规范，JVM在执行程序时会将它所管理的内存划分为5大块数据区域，分为叫做方法区，堆，虚拟机栈，本地方法栈，程序计数器。方法区和堆都是所有线程共享的数据区，其余是线程隔离的数据区<br><a id="more"></a></p><h3 id="1-虚拟机栈和本地方法栈"><a href="#1-虚拟机栈和本地方法栈" class="headerlink" title="1.虚拟机栈和本地方法栈"></a>1.虚拟机栈和本地方法栈</h3><p>虚拟机栈是线程隔离的数据区，理所当然它的生命周期随着线程的创建而产生，线程的销毁而终止。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个<code>栈帧</code>(stackframe)用于存储<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每个方法从调用到完成就是一个栈帧在虚拟机栈中入栈到出栈的过程。<br>    大多数程序员所认知的堆和栈就是JVM的全部，而所指的栈就是虚拟机栈了，或者可以说是虚拟机栈的局部变量表部分。局部变量表存放了编译器可知的各种数据类型（java的8大基本数据类型），<code>对象引用类型</code>（它不等同于对象本身，可能是一个指向对象的指针或者是指向一个代表对象的句柄或其他于此对象相关的位置）和<code>returnAddress</code>类型（指向一条字节码指令的地址）。<br>    其中64位长度的long和double类型的数据会占用两个局部变量空间，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成匹配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。<br>    在java虚拟机规范中，对这个区域定义了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展,且扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。<br>    本地方法栈和虚拟机栈所发挥的作用是非常相似的，他们之间的区别是本地方法栈是为<code>native</code>方法服务的。</p><h3 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2.程序计数器"></a>2.程序计数器</h3><p>程序计数器是一块较小的内存空间，由线程自身维护，我们可以将它看作是当前线程所执行的字节码的行号指示器。由于Java的多线程实际上是由<code>线程轮流切换并分配处理器时间片</code>来实现的，只是切换很快就让人以为是并发的。<br>因此，为了线程切换后能够回到原来的位置，每条线程都需要有一个独立的程序计数器。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是<code>Native</code>方法，这个计数器值则为空。此内存区域是java虚拟机规范中唯一一个不会存在OutOfMemoryError。</p><h3 id="3-Java堆"><a href="#3-Java堆" class="headerlink" title="3.Java堆"></a>3.Java堆</h3><p>Java堆的<code>唯一目的</code>是<code>分配对象实例</code>，几乎所有的对象实例都在这里分配内存，java规范的定义是：所有对象实例和数组都在堆上分配内存，但是随着<code>JIT编译器</code>的发展和<code>逃逸分析技术</code>的逐渐成熟，<code>栈上分配</code>、<code>标量替换优化技术</code>将会导致一些变化。</p><h3 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4.方法区"></a>4.方法区</h3><p>方法区存放的是已被虚拟机加载的<code>类信息</code>，<code>常量</code>，<code>静态变量</code>、<code>即时编译器编译后的代码</code>等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<code>非堆</code>，目的是与堆区分开来。<br>对于习惯在Hotspot虚拟机上开发、部署程序的人来说，很多人愿意把方法区称为“<code>永久代</code>”，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已，便于HotSpot收集器管理这部分内存。</p><h3 id="5-运行时常量池"><a href="#5-运行时常量池" class="headerlink" title="5.运行时常量池"></a>5.运行时常量池</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的<code>版本</code>、<code>字段</code>、<code>方</code>法、<code>接口</code>等描述信息外，还有一项是<code>常量池</code>，用于存放编译期生成的各种<code>字面量</code>和<code>符号引用</code>，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池对于Class文件常量池的另一个重要特性是具备动态特性，Java语言并不要求常量只会在编译期生成，也就是并非预置入Class文件中常量池的内容才能进入方法区常量池，运行期间的例子就是<code>String</code>的<code>intern()</code>方法</p><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分的频繁使用也会导致<code>OutOfMemoryError</code>。<br>在jdk1.4中加入了<code>NIO</code>（NewInput/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用<code>Native函数库</code>直接分配<code>堆外内存</code>，然后通过一个存储在Java堆中的<code>DirectByteBuffer对象</code>作为这块内存的引用进行操作。这样能在一些场合中显著提升性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>怎样判断对象已死，回收它的内存？</p><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p>给对象添加一个引用计数器，当有一个引用时+1，引用失效就-1.<br>优点：实现简单，判断效率高，在大部分情况下是一个不错的算法，著名的应用案列有微软公司的COM技术，Python语言，使用ActionScript3的FlashPlayer等。<br>缺点：很难解决对象的相互循环引用问题。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h3><p>基本思路：通过一系列的称为“GCRoots”的对象作为起始点，从这些节点往下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象无用。<br>在Java语言中，可作为GC Roots的对象包括下面几种：<br>1）、虚拟机栈中引用的对象<br>2）方法区中类静态变量属性引用的对象<br>3）方法区中常量的引用对象<br>4）本地方法栈中JNI引用的对象</p><h3 id="3-再谈引用"><a href="#3-再谈引用" class="headerlink" title="3.再谈引用"></a>3.再谈引用</h3><p>无论是那种算法判断存活都与“引用”相关，所以为了将引用定义的更加清晰，以便于内存空间的管理，Java将引用定义了4种，强应用，软引用，弱引用，虚引用。这4种引用强度依次减弱</p><blockquote><ul><li>强应用(Strong Reference)</li><li>软引用(Soft Reference)</li><li>弱引用(Weak Reference)</li><li>虚引用(Phantom Reference)</li></ul></blockquote><ul><li><p>强引用<br>强应用就是代码中普遍存在的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br></pre></td></tr></table></figure></li><li><p>软引用<br>软引用就是用来描述一些还有用但并非必须的对象，Java提供了SoftReference类来实现软引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sr = new SoftReference&lt;&gt;(o);</span><br><span class="line">Object object = sr.get();</span><br></pre></td></tr></table></figure></li><li><p>弱引用<br>弱引用也是用来描述非必须对象的，它的引用强度更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，Java提供了WeakReference类来实现弱引用。使用方法和软引用一致。</p></li><li>虚引用<br>它是最弱的一种引用，它的存在不会影响对象的回收，也无法使用它来获取对象的实例，它存在的唯一目的是在与它关联的对象实例被回收的时候收到一个系统通知</li></ul><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>永久代的垃圾回收主要有两个方面：废弃常量和无用的类。</p><ul><li>废弃常量<br>以常量池的字面量为例，假如<code>&quot;abc&quot;</code>字符串已经存在于常量池了，但是在当前系统中没有一个地方引用了这个常量，如果发生内存回收且有必要的话他就会被回收。</li><li>无用的类<br>判断无用的类要同时满足以下3个条件<blockquote><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>满足这些条件就有可能被虚拟机回收。</li></ul></blockquote></li></ul><h2 id="Java分代收集"><a href="#Java分代收集" class="headerlink" title="Java分代收集"></a>Java分代收集</h2><h3 id="1-Java年轻代和年老代"><a href="#1-Java年轻代和年老代" class="headerlink" title="1.Java年轻代和年老代"></a>1.Java年轻代和年老代</h3><ul><li><p>年轻代分为一个<code>Eden</code>区和两个<code>survivor</code>区（分别叫做<code>from</code>和<code>to</code>），比例一般为<code>Eden：survivor=8:1</code>，新new的对象都是分配在Eden区中（一些大对象特殊处理），经过第一次GC过后，如果对象依然被引用，那么就会移动到<code>survivor</code>区，对象在<code>survivor</code>区每多熬过一次<code>MonitorGC</code>，年龄就会增加一岁，当年龄达到一定时，会被移动到年老代中（Old区）。年轻代的对象大部分都是朝生夕死的，所以GC采用的是复制算法，复制算法就是将内存分为两块，一块用完了就将活着的对象移到另一块上面去，好处是不会产生内存碎片，缺点是会造成一半的内存浪费。</p></li><li><p>年老代：Old区<br>当年老代被塞满之后就会触发<code>Full GC</code>，非常耗时，Old区GC算法为标记-清除或者标记-整理算法。<br>标记-清除算法就是将内存还存活的对象标记，然后清除没有标记的对象，它存在两个问题，一是效率问题，标记和清除效率都不高，而是空间问题，清除之后会造成大量的空间碎片，就使得如果有比较大的对象没有连续空间分配就会再次触发GC。<br><code>标记-整理</code>算法和<code>标记-清除</code>算法的不同就是，所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p></li><li><p>堆中分配很大的对象<br>所谓大对象，是指需要大量连续内存空间的Java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行<code>Full GC</code><br>为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 <code>-XX:CMSFullGCsBeforeCompaction</code>,这个参数用于设置在执行多少次不压缩的<code>FullGC</code>后,跟着来一次带压缩的</p></li><li><p><code>System.gc()</code>方法的调用<br>此方法的调用是建议JVM进行<code>Full GC</code>,虽然只是建议而非一定,但很多情况下它会触发 <code>Full GC</code>,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可以通过<code>-XX:+ DisableExplicitGC</code>来禁止<code>RMI</code>调用<code>System.gc</code>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot 入门第一篇</title>
      <link href="/2018/10/28/springboot/"/>
      <url>/2018/10/28/springboot/</url>
      
        <content type="html"><![CDATA[<p>很久没有学习Java开发相关知识了，由于现在的工作是Android开发，所以接触Android的东西很多，但是我还是对Java后台情有独钟，现在开始从这个比较流行的技术Spring Boot开始吧。<br>Spring Boot原以为只是一个J2EE框架，其实不是，它应该是一种微服务框架，通俗的讲Spring Boot就是将我们Spring的开发工作简化了，使开发人员不在对配置文件浪费时间了。</p><h2 id="入门第一天"><a href="#入门第一天" class="headerlink" title="入门第一天"></a>入门第一天</h2><h3 id="构建maven项目"><a href="#构建maven项目" class="headerlink" title="构建maven项目"></a>构建maven项目</h3><p>1、访问<a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a> ,Spring提供自动构建demo项目，可以选择利用maven或者gradle构建项目，我选择的是maven<br>2、maven项目开发结构一般是</p><ul><li>src/main/java  程序开发以及主程序入口</li><li>src/main/resources 配置文件</li><li>src/test/java  测试程序<a id="more"></a>至此一个项目就可以跑起来了<h3 id="引入Web模块"><a href="#引入Web模块" class="headerlink" title="引入Web模块"></a>引入Web模块</h3>1、添加web依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p>2、编写一个controller<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloWorldController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@RestController注解作用是输出json格式数据<br>3、现在运行项目，打开浏览器，输入<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> ,就可以看到你的输出了</p><h3 id="Spring-Boot单元测试"><a href="#Spring-Boot单元测试" class="headerlink" title="Spring Boot单元测试"></a>Spring Boot单元测试</h3><p>打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class HelloWorldControlerTests &#123;</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void getHello() throws Exception &#123;</span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>整数中1出现的次数</title>
      <link href="/2018/04/17/timesOfInteger/"/>
      <url>/2018/04/17/timesOfInteger/</url>
      
        <content type="html"><![CDATA[<p><div><br>    <center><br>        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=552001753&auto=0&height=66"></iframe><br>    </center><br></div><br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数</p><blockquote><p>思路<br><a id="more"></a><br>按照数学的排列组合思路来解，数字1位于不同的位置，共有多少种排列，包括重复的排列。<br>1、首先拿到一个整数，有m位，数字首位为s，则0~99..99（m-1个9）这个区间1出现的次数是sum=(m-1)*10^(m-2)（1的重复排列）；<br>2、接下来count=s*sum(以2345为例，m为4，0~999区间1出现的次数为1的重复排列3*10*10=300，count=2*300=600)，统计的是后m-1位中1的重复排列与首位排列相乘；<br>3、后面如果首位s大于1，就加上10^(m-1)(以2345例子就加上1000，count=600+1000=1600)；<br>               s等于1，就加上划去首位1的数再加上1（以1345例子看就是345+1，count+=346）<br>4、接下来就是递归了，我就不赘述了，看代码。<br>详细代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int NumberOf1Between1AndN_Solution(int n) &#123;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return 0;</span><br><span class="line">        else if(n&lt;10)</span><br><span class="line">            return 1;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int length = test(n)-1;//长度减一</span><br><span class="line">        int divisor = (int) Math.pow(10,length);//除数</span><br><span class="line">        int y = n%divisor;//余数</span><br><span class="line">        int l = n/divisor;//数字首位</span><br><span class="line">int sum = (int)(length*Math.pow(10,length-1));</span><br><span class="line">        count = l*sum;</span><br><span class="line">        if(l&gt;1)</span><br><span class="line">            count+=divisor;</span><br><span class="line">        else if(l==1)</span><br><span class="line">            count=count+y+1;</span><br><span class="line">        return count+NumberOf1Between1AndN_Solution(y);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public int test(int n)&#123;</span><br><span class="line">        String str = String.valueOf(n);</span><br><span class="line">        char[]chars = str.toCharArray();</span><br><span class="line">        return chars.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo之NexT主题搭建博客踩过的坑</title>
      <link href="/2018/04/01/next/"/>
      <url>/2018/04/01/next/</url>
      
        <content type="html"><![CDATA[<p><div><br>    <center><br>        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=863046037&auto=0&height=66"></iframe><br>    </center><br></div><br>hexo+github搭建博客，自己也是拾前人牙慧，花了一天时间解决各种问题，本来很简单的问题也是在摸索中花费了大量时间，想起来就很搞笑，不过到底是解决了，好了，想要去看比较详细的过程就去: <a href="http://volcfamily.cn/2016/10/03/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">VOLC</a>这个博客吧，写的够详细了，下面写我踩过的坑吧。<br><a id="more"></a></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="1-图标问题"><a href="#1-图标问题" class="headerlink" title="1.图标问题"></a>1.图标问题</h3><p>新版的hexo不需要在menu_icons中用key-value方式为menu添加图标，在菜单项menu（名称和链接）加 || FontAwesome icon的name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / ||home</span><br><span class="line">  categories: /categories ||th</span><br><span class="line">  archives: /archives ||archive</span><br><span class="line">  tags: /tags ||tags</span><br><span class="line">  message: /message ||external-link  </span><br><span class="line">  about: /about ||user</span><br><span class="line">  #commonweal: /404.html</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="2-头像问题"><a href="#2-头像问题" class="headerlink" title="2.头像问题"></a>2.头像问题</h3><p>在blog/source文件夹下新建img文件夹，将你的头像图片放进去，在站点文件_config.yml中修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置头像</span><br><span class="line">avatar: img/hg.jpeg</span><br></pre></td></tr></table></figure><h3 id="3-在博文中添加图片"><a href="#3-在博文中添加图片" class="headerlink" title="3.在博文中添加图片"></a>3.在博文中添加图片</h3><p>1.把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true<br>2.在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件<br>3 最后在xxxx.md中想引入图片时，先把图片复制到source/_posts/xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx/图片名.jpg)</span><br></pre></td></tr></table></figure><h3 id="4-本地项目托管到github"><a href="#4-本地项目托管到github" class="headerlink" title="4.本地项目托管到github"></a>4.本地项目托管到github</h3><p>首先在你的github中new一个新的代码仓库，name：{your blog’s name}.github.io</p><blockquote><p>修改站点文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:tomycatbaby/tomycatbaby.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><blockquote><p>验证是否能否连接到github<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p></blockquote><p>成功后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi zhangsan! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><blockquote><p>上传代码 中间会输入github密码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -d</span><br></pre></td></tr></table></figure><blockquote><p>成功后就可以用 <a href="http://tomycatbaby.github.io">http://tomycatbaby.github.io</a> 访问了</p></blockquote><p><img src="/2018/04/01/next/1.png" alt="你想输入的替代文字"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
