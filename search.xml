<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android内存管理之内存抖动、内存泄露、内存溢出]]></title>
    <url>%2F2019%2F06%2F12%2Fmemory%2F</url>
    <content type="text"><![CDATA[内存抖动内存抖动的现象就是UI界面的卡顿，出现的原因就是年轻代的频繁GC。JVM的每次年轻代GC都会触发“全世界的暂停（stop-the-world）”，也就会导致卡顿。避免出现内存抖动的几点建议：1、不要在循环体内创建对象，将创建对象放到循环体外，在循环体内重用一个对象。2、自定义View的onDraw()，onMeasure()方法会多次调用，所以尽量不要在里面创建对象。3、当需要使用大量的Bitmap的时候，应该将他们缓存到数组中使用。4、同理，对于有复用的对象，可以用对象池将它缓存起来。 #内存溢出内存溢出意思就是为对象申请不到足够的内存空间了，导致OOM。内存溢出导致的原因可能是内存泄露，也有可能是JVM分配的内存真的不够使用了。在Android手机上，系统为程序最初分配的内存都是一致的，所以开发者尽量不要占用太多的内存空间，没有使用的对象及时置为null。一般情况这种场景是不会出现的，程序员一般只需要关注内存抖动和内存泄露。 内存泄露在Android手机上，内存是很珍贵的，系统为每个应用分配了固定的内存大小，如果申请不到足够的内存空间，就直接导致内存溢出。以前并没有内存泄露的概念，单纯的以为JVM会管理好所有的内存空间，并不需要开发者操心，但事实上不是。内存泄露的根本原因是一个长生命周期的对象持有了一个短生命周期的对象的引用。下面我们来看下Android上面的有哪些内存泄露的风险。 单例模式导致内存泄露，静态对象的生命周期和应用程序一样长，如果持有一个短生命周期如Activity的context就会导致activity无法被回收，所以应该使用getApplicationContext()进行初始化。 内部Handler如果持有了Activity的强引用，而handler执行没有完成，activity就已经调用onDestory了，就会导致activity无法被回收。 非静态内部类默认持有外部类对象引用。所以导致外部类销毁时仍然持有外部类引用，导致外部类无法被回收。 未去注册，如广播，服务，注册或者启动之后必须要去注册 资源对象未及时释放，如Cursor、Stream、Socket，Bitmap等在使用后要及时关闭。 集合中的对象要及时clear。 Android Studio会对代码中可能出现内存泄露的地方会给出提示，能够避免很多常见的内存泄露。对于第二种情况的内存泄露，我们一般是使用静态内部类+弱引用的方式去解决，handler不持有activity引用，而是通过弱引用去获得一个弱引用对象。第三种情况有很多例子场景：1234567891011121314151617181920212223242526272829//线程匿名内部类new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... params) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125;.execute();//线程写成静态内部类private static class MyThread implements Runnable &#123; public void run() &#123; SystemClock.sleep(20000); &#125;&#125; 总结内存泄露是非常容易出现的，上面只是一些大多数场景，还有很多需要注意的地方，特别是一些框架、组件这样的内存泄露很容易忽视。查找内存泄露的方式也很多，如LeakCanary，还有Android Studio3.0自带的Android Profiler，熟练使用这些工具能够快速的帮助自己定位内存泄露，提高程序的性能。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android有哪些处理耗时任务的方式]]></title>
    <url>%2F2019%2F05%2F09%2FandroidThread%2F</url>
    <content type="text"><![CDATA[1、IntentServiceIntentService是继承并处理异步请求的一个类，在IntentService中有一个工作线程来处理耗时操作，启动方法和常规Service一样，不同的是它不需要我们手动控制或销毁，而且IntentService可以启动多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行，必须等待前一个执行完成后才会执行下一个。看源码IntentService实际上就是内部实现了一个Handler，我们知道每启动一次service，如果这个service已经存在就会调用onStartCommand，否则就先执行onCreate方法，在onStartCommand方法中默认会调用onStart方法，IntentService的onStart方法源码如下：123456public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; 可以看到在这个方法中会向自己的handler提交一条消息，然后我们看它的handler源码的handleMessage方法：1234public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; 我们可以看到会调用onHandleIntent，然后执行完之后自动调用stopself。这就是我们使用IntentService默认必须实现它的onHandleIntent方法，而且它执行完成后会自动销毁的原因了。 2、Activity中的runOnUiThread（Runnable runnable）runOnUiThread是Activity中独有的方法，可以实现与UI主线程的通信，那它是怎么通信的呢？首先看这个方法的源码：1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 这段代码什么意思呢？就是当前的线程如果不是UI线程，就向handler提交一个任务，否则就直接调用run方法。所以这个方法就是在activity开启耗时线程执行完成后去提交UI修改。 3、View.post或postDelayed这个方法也是和runOnUiThread类似的，可以实现与UI主线程的通信，不同的是它提交到的是HandlerActionQueue去解决，而且它可以延时执行。 4、AsyncTaskAsyncTask顾名思义就是Android的异步任务，同样在异步任务中也可以执行耗时操作并更新UI，用过异步任务的都知道AsyncTask是一个抽象类，使用它必须继承它并重写它的方法，必须实现它的doInBackground方法，但是一般情况下我们都需要使用它提供的更多的功能，也就是继承AsyncTask&lt;Params,Progress,Result&gt;。这里面三个参数代表什么意思呢？第一个Params表示启动任务时你需要携带给它的参数类型，也就是调用execute方法向里面传递的参数，后面讨论它传递到哪里去了，第二个Progress表示后台任务执行中返回进度值的类型，第三个Result表示后台任务执行完成后返回结果的类型。 我们一般会重写以下4个方法： doInBackground：必须重写的方法，异步执行后台线程要完成的任务,耗时操作将在此方法中完成 onPreExecute:执行后台耗时操作前被调用,通常用于进行初始化操作. onPostExecute:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新. onProgressUpdate:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度.这4个方法的调用顺序是怎样的呢？我们从调用execute方法开始看：1234567891011121314151617181920212223@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; ... mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125;private final WorkerRunnable&lt;Params, Result&gt; mWorker;private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams;&#125;private final FutureTask&lt;Result&gt; mFuture; 我们可以看到首先是onPreExecute()最先调用的，所以我们在执行耗时操作前先使用它初始化，然后我们看到它将execute传递进来的params数组赋给了一个数组，mWorker在构造函数中初始化，然后执行exec.execute(mFuture)。1234567891011121314151617181920212223//一个双端队列，存着工作任务final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();Runnable mActive;public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; //从队列中取出下一个任务 protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; 我们看这个execute方法，它的参数是FutureTask类型的Runnable，传入的mFuture会在一个新的工作任务中执行，然后调用scheduleNext()执行下一个任务。所以现在就到了FutureTask.run方法了，mFuture是在谁初始化的呢？mFuture.run方法会调用什么呢？我们从构造函数中可以看到：1234567891011121314151617181920212223242526272829303132333435363738394041//异步任务的构造方法，默认调用public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); //WorkerRunnable的初始化 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; //FutureTask任务的初始化 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; mFuture是mWorker这个参数去初始化的，关于FutureTask的知识可以去看Java并发编程：Callable、Future和FutureTask。所以最终调用的是mWorker的call方法，在call方法里面我们看到它调用了doInBackground(mParams)，而且传入了mParams数组,doInBackground方法的返回值就是Result类型，最后调用postResult(Result result)方法，1234567private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 可以看到这个方法是向它的handler提交了一条消息。我们来看这个handler的消息处理方法:12345678910111213@Overridepublic void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125;&#125; 可以看到它只会处理两种消息，一种是异步任务执行完成，一种是在异步方法执行中调用，那我们接着看：12345678910111213141516@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125;private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 可以看到执行完成后调用的finish方法，如果正常执行完成，调用的是onPostExecute(result)，所以我们说onPostExecute方法执行在doInBackground方法后，我们说在doInBackground方法中调用publishProgress方法，会调用onProgressUpdate方法，也可以从上面的源码中得出结论。 5、HandlerThread一个Android封装的轻量级异步类。知道它的工作原理也就知道了它的优点，它是利用Thread+Handler实现的，它继承自Thread，使用它需要先创建一个HandlerThread实例，紧接着调用start将这个线程启动起来，它的run方法为：123456789101112public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 6、Handler从上面所有的方式中我们都可以看到Handler的身影，所以说学习Android必须先学好Handler。关于Handler的博客就太多了，可以看Android Handler：手把手带你深入分析 Handler机制源码,Android：这是一份Handler消息传递机制 的使用教程,Android Handler：图文解析 Handler通信机制 的工作原理,上面三篇从使用，到原理，到源码由浅入深仔细讲解了Handler机制。 问：在线程中使用Handler时(除了Android主线程)必须把它放在Looper.prepare()和Looper.loop()之间。否则会抛出RuntimeException异常。但是为什么要这么做呢？答：通俗的讲Handler机制就是主线程中有一个无限循环，与UI主线程绑定起来，它会一直循环，拿到一个消息之后就会去主线程中去调用handleMessage方法。其实就是Looper类和Handler类，Looper类封装了消息循环和消息队列，当你调用了Looper.prepare()之后，这个Looper就开始启用了，一般情况主线程在Application初始化的时候就已经自动创建一个Looper，因为一个线程就只能有一个Looper，所以在非主线程中先要调用Looper.prepare()先创建一个Looper。调用Looper.loop()之后就开始了从MessageQueue中取出消息的无限循环。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制]]></title>
    <url>%2F2019%2F04%2F23%2Fandroid%2F</url>
    <content type="text"><![CDATA[View的事件分发机制是解决滑动冲突的基础。首先要理解两个概念，View和ViewGroup，控件如Button，TexiView，ImageView等都继承自View父类，布局如LinerLayout，RelativeLayout等都继承自ViewGroup。那怎么理解这两个东西呢？我们可以将整个Activity页面看做一个容器，所有的控件（View）都装在这个容器（ViewGroup）里。 首先我们先说下结论，Android中Touch事件的传递绝对都是先到ViewGroup，然后在到View，所以无论点击了哪个控件都会先调用所在布局的dispatchTouchEvent方法，如果没有被消费掉就会向下传递到控件的dispatchTouchEvent方法。然后我们看以下三个核心方法： public boolean dispatchTouchEvent(MotionEvent ev)用来进行事件的分发。如果事件能够传递给当前的View，那么这个方法就一定会被调用，返回结果受当前View的onTouchEvent和下级的dispatchTouchEvent方法影响，表示是否消耗当前事件。 public boolean onInterceptTouchEvent(MotionEvent event)在dispatchTouchEvent方法内部调用，这个方法表示是否拦截某个事件，这个方法存在于父级的View中，也就是一般重写在ViewGroup中 public boolean onTouchEvent(MotionEvent event)在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件 用一段伪代码来表示三种方法的关系：123456789public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean comsume = false； if(onInterceptTouchEvent(ev))&#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 当一个，View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。在onTouchEvent方法中，如果当前设置的有onClickListener，那么它的click方法会被调用，可以看出我们平时所用的onClickListener优先级最低，位于末端。当一个点击事件产生后，它的传递过程遵循如下规则：Activity-&gt;Window-&gt;View,这里的View是顶级View，顶级View接收到事件后，会按照事件分发机制一步步向下分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，以此类推。如果所有的元素都不处理这个事件，那么最终这个事件会被传递给Activity处理，调用Activity的onTouchEvent方法。关于事件分发机制，这里有一些结论：（1）同一事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕，事件序列会经历down事件，以及数量不定的move事件，最后以up事件结束；（2）正常情况下，一个事件序列只能被一个View拦截消耗；（3）某个View一旦决定拦截，那么这一个事件序列只能由它自己处理，并且它的onInterceptTouchEvent方法不会再被调用（4）某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列的其他事件都不会再交给它处理，并且事件将重新交由它的父元素去处理，即调用父元素的onTouchEvent。（5）如果View不消耗除了ACTION_DOWN的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续事件。并且这些消失的点击事件会交给Activity处理。（6）ViewGroup默认不会拦截任何事件。（7）View没有onInterceptTouchEvent方法，一旦有事件传递给它就会调用它的onTouchEvent方法。（8）View的onTouchEvent默认都会消耗事件，除非它是不可点击的（clickable和longClickable同时为false，View的longClickable默认为false）。（9）View的enable属性不影响onTouchEvent的默认返回值。（10）onClick会发生的前提是当前View是可点击的，并且它收到了down和up事件。（11）事件传递过程都是由外向内的，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。mInputEventConsistencyVerifier变量是调试用的，不用理会。onFilterTouchEventForSecurity()表示是否要分发该触摸事件，具体可以看里面的源码，主要看是否该View是否被屏蔽了。intercepted变量标志Group是否拦截Touch事件的传递，会调用ViewGroup的onInterceptTouchEvent方法进行判定。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM日记(一)]]></title>
    <url>%2F2019%2F04%2F17%2FJVM1%2F</url>
    <content type="text"><![CDATA[Java虚拟机第一篇熟读《深入理解java虚拟机》，将自己的所学所感记录下来 运行时数据区根据java虚拟机规范，JVM在执行程序时会将它所管理的内存划分为5大块数据区域，分为叫做方法区，堆，虚拟机栈，本地方法栈，程序计数器。方法区和堆都是所有线程共享的数据区，其余是线程隔离的数据区 1.虚拟机栈和本地方法栈虚拟机栈是线程隔离的数据区，理所当然它的生命周期随着线程的创建而产生，线程的销毁而终止。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧(stackframe)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到完成就是一个栈帧在虚拟机栈中入栈到出栈的过程。 大多数程序员所认知的堆和栈就是JVM的全部，而所指的栈就是虚拟机栈了，或者可以说是虚拟机栈的局部变量表部分。局部变量表存放了编译器可知的各种数据类型（java的8大基本数据类型），对象引用类型（它不等同于对象本身，可能是一个指向对象的指针或者是指向一个代表对象的句柄或其他于此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用两个局部变量空间，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成匹配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在java虚拟机规范中，对这个区域定义了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展。如果扩展时无法申请到足够的内存，就会抛出抛出OutOfMemoryError异常。 本地方法栈和虚拟机栈所发挥的作用是非常相似的，他们之间的区别是本地方法栈是为native方法服务的。 2.程序计数器程序计数器是一块较小的内存空间，由线程自身维护，我们可以将它看作是当前线程所执行的字节码的行号指示器。由于Java的多线程实际上是由线程轮流切换并分配处理器时间片来实现的，只是切换很快就让人以为是并发的。因此，为了线程切换后能够回到原来的位置，每条线程都需要有一个独立的程序计数器。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器值则为空。此内存区域是java虚拟机规范中唯一一个不会存在OutOfMemoryError。 3.Java堆Java堆的唯一目的是分配对象实例，几乎所有的对象实例都在这里分配内存，java规范的定义是：所有对象实例和数组都在堆上分配内存，但是随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些变化。 4.方法区方法区存放的是已被虚拟机加载的类信息，常量，静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做非堆，目的是与堆区分开来。对于习惯在Hotspot虚拟机上开发、部署程序的人来说，很多人愿意把方法区称为“永久代”，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已，便于HotSpot收集器管理这部分内存。 5.运行时常量池运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池对于Class文件常量池的另一个重要特性是具备动态特性，Java语言并不要求常量只会在编译期生成，也就是并非预置入Class文件中常量池的内容才能进入方法区常量池，运行期间的例子就是String的intern()方法 6.直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分的频繁使用也会导致OutOfMemoryError。在jdk1.4中加入了NIO（NewInput/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场合中显著提升性能，因为避免了在Java堆和Native堆中来回复制数据。 垃圾收集怎样判断对象yisi已死，回收它的内存？ 1.引用计数算法给对象添加一个引用计数器，当有一个引用时+1，引用失效就-1.优点：实现简单，判断效率高，在大部分情况下是一个不错的算法，著名的应用案列有微软公司的COM技术，Python语言，使用ActionScript3的FlashPlayer等。缺点：很难解决对象的相互循环引用问题。 2.可达性分析算法基本思路：通过一系列的称为“GCRoots”的对象作为起始点，从这些节点往下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象无用。在Java语言中，可作为GC Roots的对象包括下面几种：1）、虚拟机栈中引用的对象2）方法区中类静态变量属性引用的对象3）方法区中常量的引用对象4）本地方法栈中JNI引用的对象 3.再谈引用无论是那种算法判断存活都与“引用”相关，所以为了将引用定义的更加清晰，以便于内存空间的管理，Java将引用定义了4种，强应用，软引用，弱引用，虚引用。这4种引用强度依次减弱 强应用(Strong Reference) 软引用(Soft Reference) 弱引用(Weak Reference) 虚引用(Phantom Reference) 强引用强应用就是代码中普遍存在的写法。 1Object o = new Object(); 软引用软引用就是用来描述一些还有用但并非必须的对象，Java提供了SoftReference类来实现软引用 123Object o = new Object();SoftReference&lt;Object&gt; sr = new SoftReference&lt;&gt;(o);Object object = sr.get(); 弱引用弱引用也是用来描述非必须对象的，它的引用强度更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，Java提供了WeakReference类来实现若引用。使用方法和软引用一致。 虚引用它是最弱的一种引用，它的存在不会影响对象的回收，也无法使用它来获取对象的实例，它存在的唯一目的是在与它关联的对象实例被回收的时候收到一个系统通知 回收方法区永久代的垃圾回收主要有两个方面：废弃常量和无用的类。 废弃常量以常量池的字面量为例，假如&quot;abc&quot;字符串已经存在于常量池了，但是在当前系统中没有一个地方引用了这个常量，如果发生内存回收且有必要的话他就会被回收。 无用的类判断无用的类要同时满足以下3个条件 该类所有的实例都已经被回收，也就是Java堆中不存在该类的实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。满足这些条件就有可能被虚拟机回收。 Java分代收集1.Java年轻代和年老代 年轻代分为一个Eden区和两个survivor区（分别叫做from和to），比例一般为Eden：survivor=8:1，新new的对象都是分配在Eden区中（一些大对象特殊处理），经过第一次GC过后，如果对象依然被引用，那么就会移动到survivor区，对象在survivor区每多熬过一次MonitorGC，年龄就会增加一岁，当年龄达到一定时，会被移动到年老代中（Old区）。年轻代的对象大部分都是朝生夕死的，所以GC采用的是复制算法，复制算法就是将内存分为两块，一块用完了就将活着的对象移到另一块上面去，好处是不会产生内存碎片，缺点是会造成一半的内存浪费。 年老代：Old区当年老代被塞满之后就会触发Full GC，非常耗时，Old区GC算法为标记-清除或者标记-整理算法。标记-清除算法就是将内存还存活的对象标记，然后清除没有标记的对象，它存在两个问题，一是效率问题，标记和清除效率都不高，而是空间问题，清除之后会造成大量的空间碎片，就使得如果有比较大的对象没有连续空间分配就会再次触发GC。标记-整理算法和标记-清除算法的不同就是，所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 堆中分配很大的对象所谓大对象，是指需要大量连续内存空间的Java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的FullGC后,跟着来一次带压缩的 System.gc()方法的调用此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 入门第一篇]]></title>
    <url>%2F2018%2F10%2F28%2Fspringboot%2F</url>
    <content type="text"><![CDATA[很久没有学习Java开发相关知识了，由于现在的工作是Android开发，所以接触Android的东西很多，但是我还是对Java后台情有独钟，现在开始从这个比较流行的技术Spring Boot开始吧。Spring Boot原以为只是一个J2EE框架，其实不是，它应该是一种微服务框架，通俗的讲Spring Boot就是将我们Spring的开发工作简化了，使开发人员不在对配置文件浪费时间了。 入门第一天构建maven项目1、访问http://start.spring.io/ ,Spring提供自动构建demo项目，可以选择利用maven或者gradle构建项目，我选择的是maven2、maven项目开发结构一般是 src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 至此一个项目就可以跑起来了引入Web模块1、添加web依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 2、编写一个controller1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;Hello World&quot;; &#125;&#125; @RestController注解作用是输出json格式数据3、现在运行项目，打开浏览器，输入http://localhost:8080/hello ,就可以看到你的输出了 Spring Boot单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数中1出现的次数]]></title>
    <url>%2F2018%2F04%2F17%2FtimesOfInteger%2F</url>
    <content type="text"><![CDATA[求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数 思路按照数学的排列组合思路来解，数字1位于不同的位置，共有多少种排列，包括重复的排列。1、首先拿到一个整数，有m位，数字首位为s，则0~99..99（m-1个9）这个区间1出现的次数是sum=(m-1)*10^(m-2)（1的重复排列）；2、接下来count=s*sum(以2345为例，m为4，0~999区间1出现的次数为1的重复排列3*10*10=300，count=2*300=600)，统计的是后m-1位中1的重复排列与首位排列相乘；3、后面如果首位s大于1，就加上10^(m-1)(以2345例子就加上1000，count=600+1000=1600)； s等于1，就加上划去首位1的数再加上1（以1345例子看就是345+1，count+=346）4、接下来就是递归了，我就不赘述了，看代码。详细代码 12345678910111213141516171819202122232425262728import java.util.HashMap;import java.util.Map;public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; if(n==0) return 0; else if(n&lt;10) return 1; int count = 0; int length = test(n)-1;//长度减一 int divisor = (int) Math.pow(10,length);//除数 int y = n%divisor;//余数 int l = n/divisor;//数字首位 int sum = (int)(length*Math.pow(10,length-1)); count = l*sum; if(l&gt;1) count+=divisor; else if(l==1) count=count+y+1; return count+NumberOf1Between1AndN_Solution(y); &#125; public int test(int n)&#123; String str = String.valueOf(n); char[]chars = str.toCharArray(); return chars.length; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之NexT主题搭建博客踩过的坑]]></title>
    <url>%2F2018%2F04%2F01%2Fnext%2F</url>
    <content type="text"><![CDATA[hexo+github搭建博客，自己也是拾前人牙慧，花了一天时间解决各种问题，本来很简单的问题也是在摸索中花费了大量时间，想起来就很搞笑，不过到底是解决了，好了，想要去看比较详细的过程就去: VOLC这个博客吧，写的够详细了，下面写我踩过的坑吧。 遇到的问题1.图标问题新版的hexo不需要在menu_icons中用key-value方式为menu添加图标，在菜单项menu（名称和链接）加 || FontAwesome icon的name 123456789101112menu: home: / ||home categories: /categories ||th archives: /archives ||archive tags: /tags ||tags message: /message ||external-link about: /about ||user #commonweal: /404.html# Enable/Disable menu icons.menu_icons: enable: true 2.头像问题在blog/source文件夹下新建img文件夹，将你的头像图片放进去，在站点文件_config.yml中修改 12# 设置头像avatar: img/hg.jpeg 3.在博文中添加图片1.把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true2.在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件3 最后在xxxx.md中想引入图片时，先把图片复制到source/_posts/xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) 4.本地项目托管到github首先在你的github中new一个新的代码仓库，name：{your blog’s name}.github.io 修改站点文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:tomycatbaby/tomycatbaby.github.io.git branch: master 验证是否能否连接到github1$ ssh -T git@github.com 成功后1Hi zhangsan! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 上传代码 中间会输入github密码 1hexo -d 成功后就可以用 http://tomycatbaby.github.io 访问了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
