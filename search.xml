<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2F2020%2F03%2F25%2Fvolatile%2F</url>
    <content type="text"><![CDATA[介绍volatile关键字，java给出的线程安全的轻量级实现1、保证可见性，用volatile修饰的变量每次都是从内存中读取2、禁止指令重排序，用volatile修饰的变量禁止指令重排优化3、不保证原子性，要保证原子性的话需要使用synchronize关键字或者concurrent包下的原子类12345678910111213141516public class Singleton &#123; private static volatile Singleton instance; private Singleton()&#123;&#125; // DCL public static Singleton getInstance()&#123; if(instance ==null)&#123; //第一次检查 synchronized (Singleton.class)&#123; if(instance == null)&#123; //第二次检查 instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 以上是常见的双重校验的单例模式instance = new Singleton(),分为三步：1、给instance分配内存，2、调用它的构造方法来初始化对象，3、将instance对象指向初始分配的内存空间（这一步执行了instance就非null） 在这三步中，第二步和第三步不存在数据依赖，如果虚拟机指令重排优化，就会存在其他线程访问的时候instance为非null的情况，然后访问就会出错这个版本的双重校验单例模式，使用了volatile关键字去禁止指令重排序来保证线程安全。 性能当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中，而volatile变量会跳过CUP cache，每次读都是从内存中读取volatile的性能经过了很多的优化，建议使用，它读的性能是很高的，几乎和非volatile变量一致，写的性能就差了许多，因为内存界定。volatile经过写操作后会做两件事，1、同步到系统内存中，2、使其他CUP缓存到的volatile变量的内存地址失效，必须重新从内存中读取 使用场景这个关键字的使用场景，就是存在原子性问题就需要注意，是可以使用它来保证线程的安全 volatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的零碎知识点]]></title>
    <url>%2F2020%2F01%2F05%2Fandroid1%2F</url>
    <content type="text"><![CDATA[1、Android 项目中 assets 目录和 res 目录有什么区别assets下可以新建子目录，res下的子目录不能再新建子目录assets也会随着apk一起打包，但是不会进行编译，res目录下的文件都会进行编译后使用R.的方式就能使用assets使用是需要用AssetManager取出输入流使用的 2、如何结束一个正在运行的线程使用interrupted()方法打断线程的运行，不建议使用已遗弃的stop方法，因为stop的本质上是不安全的，用 Thread.stop 来终止线程将释放它已经锁定的所有监视器（作为沿堆栈向上传播的未检查 ThreadDeath 异常的一个自然后果）。如果以前受这些监视器保护的任何对象都处于一种不一致的状态，则损坏的对象将对其他线程可见，这有可能导致任意的行为。stop的许多使用都应由只修改某些变量以指示目标线程应该停止运行的代码来取代。目标线程应定期检查该变量，并且如果该变量指示它要停止运行，则从其运行方法依次返回。如果目标线程等待很长时间（例如基于一个条件变量），则应使用 interrupt 方法来中断该等待 3、如何获取某个 View 的大小并动态改变 View 的大小LayoutParams动态改变view的大小 4、String、StringBuilder、StringBuffer 区别运行速度：StringBuilder&gt;StringBuffer&gt;String线程安全：String，StringBuffer非线程安全：StringBuilderString是字符串常量，每次的修改会导致对象的不断创建和回收，所以它最慢StringBuffer由于其中很多方法都是带有synchronize关键字的，所以它的速度比StringBuilder慢String是不可变类，所以String是线程安全的缓冲区区别：StringBuffer每次toString会直接使用toStringCache来构造一个字符串StringBuilder则每次需要复制一次字符数组，然后构造一个字符串 5、泛型擦除修饰成员变量等类结构相关的泛型不会被擦除Java的容器类泛型只对编译器有效，作为编码时的检验，编译为字节码后会自动将泛型去掉。 6、ArrayMap、HashMap、SparseArray 原理HashMap是Java的数据结构，ArrayMap和SparseArray是Android特有的类HashMap是数组加链表的存储value的结构，利用key的hashcode与容量-1相与去算出位于数组哪个位置，hash冲突后就加到链表中，java8之前都是链表，java8之后链表长度大于7后自动转换成红黑树（O(lgn)），优点是查找速度更快，缺点是会增加大量内存使用。SparseArray很简单粗暴，利用Int作为key。它保存两个数组，一个时Int类型的key数组，一个是Object类型的value数组，加入数据是先用二分查找去查找是否在key数组已经存在有这个相同的key，没有就新增，有就返回对应value的在数组中下标，然后替换，这个数据类的缺点是增删改查都会使用二分查找，不适用存储大量数据ArrayMap和SparseArray类似，区别是它使用hash值存储在key数组中的，SparseArray是直接存储int在key数组中，缺点也是查找效率没HashMap高，它主要是提高内存效率。 7、Fragment 添加方式，add、replace、show 区别add():向Activity加入一个片段，这个片段在activity容器中有他自己的视图。hide():隐藏Fragment，已经添加到父容器中的Fragment有关，隐藏Fragment的View。show():显示被隐藏的Fragment，这仅仅对已经添加到activity中的Fragment有关,显示Fragment的View。detach():Fragment的视图被销毁，但是它的状态没有被销毁，还是被FragmentMenager管理。attach():Fragment的view重新加载到UI视图中，并显示，也就是执行onCreateView()→onActivityCreate()→onStart()→onResume()。replace():就相当于执行remove(Fragment)→add(int, Fragment, String)这两个方法 8、volatile 关键字作用禁止指令重排序，轻量级的synchronized，保重了共享变量的“可见性”，可见性的意思是一个线程修改变量的值是另一个线程是能读到这个值当一个变量被 volatile 修饰时，任何线程对它的写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据 9、Binder 机制Binder 是一种跨进程的通信方式，它也是一个类，实现了IBinder接口，从framework层面讲，它是ServiceManager链接各个service的桥梁，它也是应用层bindService之后给客户端提供调用服务端的服务或数据，服务包括普通服务和AIDL 10、HTTP 版本之间区别一、HTTP1.0和HTTP1.1的区别HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 1、缓存处理。在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 2、带宽优化及网络连接的使用。HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 3、错误通知的管理。在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 4、Host头处理。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 5、长连接。HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点二、HTTP2.0和HTTP1.X相比的新特性1、新的二进制格式（Binary Format）。HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 2、多路复用（MultiPlexing）。即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 3、header压缩。如HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 4、服务端推送（server push）。同SPDY一样，HTTP2.0也具有server push功能。 三、HTTPS与HTTP的一些区别1、HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。2、HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。3、HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 11、invalidate()、requestLayout() 区别： requeLayout() : 控件会重新执行 onMesure() onLayout() ,比如 ScrollView中有LinearLaout ，LinearLayout里面有纵向排列的ImageView和TextView,那么假如ImageView的长宽发生了变化，而要立即在手机上显示这个变化的话，就可调用 imageView.requestLayout();这样的话ScrollView 会重新执行onMesure()这个方法会确定控件的大小然后在确定出自己的宽高，最后在执行onLayout()，这个方法是对所有的子控件进行定位的。他只调用measure()和layout()过程，不会调用draw()。2.invalidate() :是自定义View 的时候，重新执行onDraw()方法，当view只在内容和可见度方面发生变化时调用。3 layout()：对控件进行重新定位执行onLayout()这个方法，比如要做一个可回弹的ScrollView，思路就是随着手势的滑动子控件滑动，那么我们可以将ScrollView的子控件调用layout（l,t,r,b）这个方法就行了。12、ArrayList 怎么实现线程安全使用synchronized关键字在调用这个实例的地方加锁或者使用Collections.synchronizedList()方法将一个ArrayList变成一个增删改查都加锁的类的实例，还有就是使用CopyOnWriteArrayList，这个类是线程安全的13、ConcurrentHashMap为什么效率比Hashtable高？jdk1.7下Segment（分段锁）类，它继承自ReentrantLock。ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问 坏处这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长 好处写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上）。 jdk1.8JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。Node：保存key，value及key的hash值的数据结构。其中value和next都用volatile修饰，保证并发的可见性。CAS+Synchronized保证线程安全 14、List、Map、Set 哪个能存null，哪个能重复？List是数组结构，插入数据时它并不对是否是null进行判断，所以它不仅允许null，还可以有多个nullSet的底层实现就是用Map的哈希值去维持唯一，所以说它是允许有null的，但是只能有一个Map允许key和value都允许null，Hashtable都不允许null，他们都不允许重复key 15、Handler epoll 机制管道是Linux系统中的一种进程间通信机制，简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。这个等待和唤醒的操作是如何进行的呢，这就要借助Linux系统中的epoll机制了。 Linux系统中的epoll机制为处理大批量句柄而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。但是这里我们其实只需要监控的IO接口只有mWakeReadPipeFd一个，即前面我们所创建的管道的读端，为什么还需要用到epoll呢？有点用牛刀来杀鸡的味道。其实不然，这个Looper类是非常强大的，它除了监控内部所创建的管道接口之外，还提供了addFd接口供外界面调用，外界可以通过这个接口把自己想要监控的IO事件一并加入到这个Looper对象中去，当所有这些被监控的IO接口上面有事件发生时，就会唤醒相应的线程来处理，不过这里我们只关心刚才所创建的管道的IO事件的发生epoll_wait 监控的超时时间为timeoutMillis]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活动的launchMode]]></title>
    <url>%2F2019%2F08%2F25%2FlaunchMode%2F</url>
    <content type="text"><![CDATA[启动模式Android的Activity有四种启动模式都清楚，标准启动模式standard，栈顶复用singleTop，栈内复用singleTask，单实例模式singleInstance，他们都在在AndroidManifeast中使用 standard：每次启动startActivity都会在任务栈中创建一个新的Activity实例，重新走一遍活动的生命周期，谁去启动这个新实例，这个新的实例就会创建在谁的任务栈中。非新手都知道在service中或者使用ApplicationContext去启动活动都会出异常，导致启动失败，根本原因就是因为service上下文没有对应的任务栈，所以我们就会给它加上FLAG_ACTICITY_NEW_TASK这个flag，这样就会为它创建新的任务栈，一个singleTask启动的 singleTop：在这种模式下，如果需要启动的Activity位于当前的栈顶，那么这个Activity不会被重新创建，它的onNewIntent会被回调，如果Activity已经存在但是不在栈顶，依然会重新创建 singleTask：这是一种单实例模式，在这种模式下，同一个栈中只会存在同一种实例，同样如果它在栈中存在也会回调onNewIntent，同时singleTask有clearTop的效果，位于它之上的实例会全部出栈 singleInstance：这是一种加强的单实例模式，它具有singleTask所有的特性，再加上它被创建后会位于一个单独的任务栈中，这种模式的栈只有一个实例。 多次提到某个Activity所需的任务栈，什么是Activity所需的任务栈呢？从TaskAffinity这个配置参数说起，可以翻译为任务相关性，这个参数标注了一个Activity所需任务栈的名字，默认情况下，Activity的任务栈名字为包名，这个参数主要和singleTask或者allowTaskReparenting属性配对使用，其他情况下没有意义。另外任务栈分为前台任务栈和后台任务栈，后台任务栈的Activity处于暂停状态，通过切换将后台任务切换到前台。 singleTask和TaskAffinity配合使用时，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行到名字和TaskAffinity相同的任务栈中。singleTask和allowTaskReparenting配合使用时，情况比较复杂了，简而言之就是A应用启动B应用的Activity C，如果Activity C的allowTaskReparenting是true，则已启动的活动C会从应用A的任务栈移动到应用B的任务栈，点开B应用不是打开主界面而是进入已启动的活动C。 另外的一种指定启动模式的方法，就是在启动的Intent中设置FLAG标志，这个的优先级是高于xml中直接指定的，同时存在以第二种为准，其次它们的范围有所限制，xml中不能使用FLAG_ACTIVITY_CLEAR_TOP，Intent中不能指定singleInstance，跟launchMode相关是哪些标志呢？ FLAG_ACTIVITY_NEW_TASK FLAG_ACTIVITY_SINGLE_TOP FLAG_ACTIVITY_CLEAR_TASK FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_NEW_TASK 设计的初衷是让Activity在目标taskAffinity中启动]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于Handler]]></title>
    <url>%2F2019%2F07%2F03%2Fhandler%2F</url>
    <content type="text"><![CDATA[1、关于handler消息机制有哪些重要关键的类？Handler，Message，MessageQueue，LooperHandler是发送的处理消息的类，发送消息的方法都是final修饰的，handleMessage方法是空方法，我们必须要去重写它Message是消息体，包括what，arg1，arg2,obj这4个发送消息必须显示赋予的，然后Message类自己有一个消息池，它的使命是减少重复new Message对象，浪费资源。最后要提到的关键的属性就是when，target，callback这几个属性是干嘛的后面再讲Looper，消息循环器，作用是从MessageQueue中取出消息体，然后去处理MessageQueue，消息队列，存放消息体的数据结构，作用是存放消息体，阻塞Looper消息循环等 2、handler发送消息的方式两种方式：post和send123456789handler.obtainMessage().sendToTarget();handler.post();//直接执行handler.postAtTime()//某个时间点执行handler.postDelayed()//延迟多少事件执行handler.postAtFrontOfQueue()//放到消息队列前面执行handler.sendMessage();handler.sendMessageAtTime()//某个时间点执行handler.sendEmptyMessage()//向消息队列中发送一个只带what不带其他obj的消息Message.obtain().sendToTarget();//Message.obtain()是建议使用的生成Message对象的方式，Message类维护了一个消息池，复用Message对象 上面没有包括所有的发送方式，但是所有的发送方式都会走到Handler的两个方法： 1.sendMessageAtTime(Message msg, long uptimeMillis)2.sendMessageAtFrontOfQueue(Message msg) 然后这两个方法殊途同归都会走到enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)这个方法，区别是方法1的uptimeMillis参数是SystemClock.uptimeMillis() + delayMillis，delayMillis就是提供的延时时间，没有值或者小于0默认为0，方法2的uptimeMillis是0。ps: SystemClock.uptimeMillis() 从开机到现在的毫秒数（手机睡眠的时间不包括在内）；System.currentTimeMillis() 从1970年1月1日 UTC到现在的毫秒数；这个值是不准的，可以被修改。 12345678private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this;//将消息体的target绑定为当前的handler if (mAsynchronous) &#123; //设置消息体是不是异步，生成消息体时如果没有设置那一定就是false，如果要设置调用消息体的setAsynchronous()设置 msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 无论是那种方式，都直接或间接需要一个handler对象，Handler类的构造函数需要初始化4个属性mLooper，mQueue，mCallback，mAsynchronous，分别讲下这4个怎么赋值的，先讲下Handler的构造函数，明面上的有三个，撸到底就两个@hide的构造函数。123456789101112131415161718192021222324252627281、//调用这个构造函数的前提是传入了looper对象，或者looper和callback一起传入，async默认为false public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue;//用Looper循环器的消息队列去初始化handler的消息队列 mCallback = callback;//没传就为null mAsynchronous = async; &#125;2、//调用这个构造函数的前提是传入了callback对象，或者什么都没传，async默认为false public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 从上面我们可以看到显式new出来的方式都是同步的，异步的怎么生成？1Handler.createAsync(@NonNull Looper looper, @NonNull Callback callback) 就是上面的方法了，它是一个静态的，方法体内默认async为true。接下来分析这几个属性：1、Looper:上面两种方式，一种是自己传进去，另一种是自己获取，也就是Looper.myLooper()重点说下第二种，Looper类中维护了一个ThreadLocal，使用第二种方式获取也就是从当前本地线程副本中去获取Looper，在不同的线程中这个副本是不一致的，所以说在新开启的线程中，这个副本是get到的是null。所以如果handler初始化时如果没有传入looper的话，那就是第二种Handler的构造函数，它会默认调用当前线程绑定的Looper，可以看到如果获取的looper为null，会抛出运行时异常，所以你知道了吧，为什么在非主线程中使用新建使用handler的话，必须先调用Looper.prepare()方法2、MessageQueue的初始化都是由Looper中的消息队列来完成的，Looper中的属性是在构造器中初始化的，而MessageQueue类的构造器是这样的1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; 需要传入一个是否允许停止的标志位，可以看到还使用了一个nativeInit(),这个是一个native方法。MessageQueue中有很多native方法，包括初始消息队列，销毁消息队列，唤醒消息队列，都是利用了native层方法，在native层也有一个消息队列。3、Callback，Handler中封装的一个接口，里面只有一个handleMessage方法，它的执行顺序在Handler的handlerMessage空方法之前，具体可以看loop循环时分发消息调用handler的消息分发方法1234567891011121314//handler处理消息分发的唯一的入口 public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg);// =&gt;msg.callback.run(); &#125; else &#123; if (mCallback != null) &#123; //handler重写的handleMessage执行顺序在callabck的handleMessage之后，也就是callback不为null，且callback的handleMessage返回true，这个消息就被消化掉了，不会再执行Handler重写的handleMessage if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 4、async异步属性，这个属性唯一在handler中使用的位置：12345678//这里是消息体入消息队列的唯一入口 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true);//为入队的消息设置为异步消息 &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 3、我们知道handler可以发送延时消息，那它是怎样实现延时处理的？ 提到延时，可以想起来在每个消息体入消息队列之前，都会初始化when属性，这个属性是一个时间点，在loop方法中会去从消息队列中取消息。我们来看消息怎样取出来的12345678910111213141516171819202122232425 public static void loop() &#123; //死循环一直跑 for (;;) &#123; //从messageQueue中取出消息,如果是UI主线程的Looper，这里就有可能阻塞，因为UI主线程的Looper是必须一直跑起来的，很多其他的消息行为，如启动Activity之类的都是在这个Looper中接收处理的，而如果是其他的另开的线程，使用了Looper.prepare和Looper.loop，是定义了自己的线程循环器，根据源码上来看，这个定义的looper是可以停止的，也就是说，当消息队列中没有消息之后，这个消息队列返回的msg就为空然后loop方法就会return。 ...... Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ..... try &#123; msg.target.dispatchMessage(msg);//去调用消息队列绑定的handler去执行消息分发 dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ...... //消息体处理完之后进行销毁 msg.recycleUnchecked(); &#125; &#125; 可以看到 Message msg = queue.next()这一行代码是有可能阻塞的，当时间还没到我们预设的时间，消息队列就没被唤醒，也就取不出消息体，消息就是这样实现延时的。我们再看下next方法,去从中找出它阻塞的证据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0;//字面意思是取出下一个消息体的阻塞时间，用于确定消息队列应处于出队状态还是等待状态,-1表示等待状态，0表示返回，&gt;0表示阻塞多少毫秒 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis);//这里就是实现阻塞的地方了，C方法 synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //target就是处理的handler，如果取到的消息不为null，但是handler为null，就遗弃这个消息 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg =msg.next; //这两句是将当前指向的msg向后移直到msg不为null且当前的消息不是异步消息 &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; //表示当前取出的消息还没到预定执行的时间点，设置一个超时时间去唤醒 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 取出一个消息体 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; //取出的msg为null，然后将这个参数置为-1，然后去阻塞 nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. //已处理所有待处理的消息 if (mQuitting) &#123; dispose();//截断这个消息队列，在调用了quit()方法后会调用 return null; &#125; nextPollTimeoutMillis = 0; &#125;&#125; 4、在子线程使用handler要注意什么？新开子线程的Looper的ThreadLocal中没有绑定looper，所以必须先调用Looper.prepare()方法先初始化Looper和MessageQueue，或者在Handler构造器中传入已经初始化好的looper，比如Handler h = new MyHandler(Looper.getMainLooper());这种方式，而如果要绑定自己线程的循环器和消息队列：12345Looper.prepare();Handler h = new Handler();//初始化handler必须在prepare后面h.sendEmptyMessage(1);//sendmessage必须在loop()前面，原因是loop()是个死循环，它没有销毁之前，后面的语句都不会执行Looper.loop();]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android标签]]></title>
    <url>%2F2019%2F06%2F14%2Flabel%2F</url>
    <content type="text"><![CDATA[ViewStub 懒加载最开始接触ViewStub是从DecorView中认识的，都知道DecorView是顶级的View，它是一个线性布局，它有两个子View：ViewStub和FrameLayout,帧布局中包括一个FitWindowsLinearLayout布局，FitWindowsLinearLayout包含ViewStubCompat和ContentFrameLayout，而我们使用setContentView放进去的布局文件就是放在ContentFrameLayout这个布局之中。而我们最开始就接受到的知识是DecorView是两个部分组成的，一个是titleView，另一个就是ContentView（可以用findViewById(android.R.id.content)获取）。ViewStub也是继承自View，它使用的是惰性加载的方式，也就是即使它已经包含于布局文件中，但是不主动加载，它就是为空的。ViewStub一般用于需要展示另外的一个效果，如网络加载失败的页面显示。 ViewStub的加载原理ViewStub只能加载一次，重复加载会导致异常，这是因为ViewStub只要加载一次自身就会被移除，并把自身所包含的内容传递给父布局。12345&lt;ViewStub android:id=&quot;@+id/vs&quot; android:layout=&quot;@layout/activity_detail&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 调用的ViewStub的inflate()方法就会加载布局，还有一种加载它的方法，在它的setVisibility方法的源码中可以看到。123456789101112131415public void setVisibility(int visibility) &#123; if (mInflatedViewRef != null) &#123; View view = mInflatedViewRef.get(); if (view != null) &#123; view.setVisibility(visibility); &#125; else &#123; throw new IllegalStateException(&quot;setVisibility called on un-referenced view&quot;); &#125; &#125; else &#123; super.setVisibility(visibility); if (visibility == VISIBLE || visibility == INVISIBLE) &#123; inflate(); &#125; &#125;&#125; 当你设置visibility为VISIBLE或INVISIBLE就会调用inflate()去加载 includeinclude的用法也很简单，它的出现提高了布局的可重用性，使得更方便控制管理。1234&lt;include layout=&quot;@layout/app_bar_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 使用include可能遇到的坑：1、标签当中可以重写layout的所有属性，在里面覆写的layout属性会覆盖掉实际layout（如上就是app_bar_main）布局的layout属性），另外需要注意的是如果要覆写layout属性的话，必须要覆写layout_width和layout_height，Android Studio一般也会提示。2、一个布局文件中如果有多个标签需要设置id才能找到对应的子控件，否则只能找到第一个include的布局文件及控件3、如果你在和include的根布局文件都设置了id，需要保持一致，否则可能获取不到根布局对象。 merge标签是配和标签使用的，作为include的根布局标签，意义是帮助include标签去除一层多余的ViewGroup，具体很简单就不用多说，想想就明白了。使用merge的注意事项：1、根布局是FrameLayout且不需要设置background或padding等属性，可以用merge标签代替，因为setContentView就是加载到帧布局之中的。2、因为merge不是View，所以在通过LayoutInflate.inflate()方法渲染的时候，第二个参数必须指定一个父容器，第三个参数必须为true，由于merge不是View，所以对merge标签的所有设置都是无效的。 附录：一个求Activity最大层级的算法在网上看到过一个递归版本的这种算法，那既然递归版本的有了，就来一个非递归版本的。其实这个算法可以看做是一颗树（因为View的层级就是一棵View树），那其实就是利用树的层次遍历，算出最深的节点，树的层次遍历怎么实现也就很简单拉，就是把每一层从左到右依次放入一个队列中，从队列头部取出，然后将它的子节点放到队列末尾，一直循环执行下去知道队列为空。那我们并不要这个层次遍历输出的结果，我们只需要最大深度该怎么实现，难搞啊。不慌，问题不大，我们可以在一层子节点的队列尾部加上一个标志，等到队列的同级的节点都出了队列的时候，就到了这个标志，就意味着一层已经遍历完了，然后再将这个标志移到队列的尾部，继续执行，那不就行了，但是要注意，如果没有下一层，那么一直移动就会造成死循环，所以排除掉这种情况。好，下面上代码： 1234567891011121314151617181920212223242526272829private void findDeep() &#123; ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView(); //TickView一个自定义View，用来当做标志位 TickView tickView = new TickView(getApplicationContext()); Queue&lt;View&gt; queue = new LinkedList&lt;&gt;(); queue.add(viewGroup); queue.add(tickView); int deep = 0; while (!queue.isEmpty()) &#123; if (queue.peek() instanceof ViewGroup) &#123; viewGroup = (ViewGroup) queue.poll(); int count = viewGroup.getChildCount(); if (count &gt; 0) &#123; for (int i=0;i&lt;count;i++)&#123; if (viewGroup.getChildAt(i) instanceof ViewGroup)&#123; queue.offer(viewGroup.getChildAt(i)); &#125; &#125; &#125; &#125; else if (queue.peek() instanceof TickView) &#123; queue.poll(); deep++; if (!queue.isEmpty())&#123; queue.offer(tickView); &#125; &#125; &#125; Log.d(TAG, &quot;findDeep: &quot;+deep);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存管理之内存抖动、内存泄露、内存溢出]]></title>
    <url>%2F2019%2F06%2F02%2Fmemory%2F</url>
    <content type="text"><![CDATA[内存抖动内存抖动的现象就是UI界面的卡顿，出现的原因就是年轻代的频繁GC。JVM的每次年轻代GC都会触发“全世界的暂停（stop-the-world）”，也就会导致卡顿。避免出现内存抖动的几点建议：1、不要在循环体内创建对象，将创建对象放到循环体外，在循环体内重用一个对象。2、自定义View的onDraw()，onMeasure()方法会多次调用，所以尽量不要在里面创建对象。3、当需要使用大量的Bitmap的时候，应该将他们缓存到数组中使用。4、同理，对于有复用的对象，可以用对象池将它缓存起来。 内存溢出内存溢出意思就是为对象申请不到足够的内存空间了，导致OOM。内存溢出导致的原因可能是内存泄露，也有可能是JVM分配的内存真的不够使用了。在Android手机上，系统为程序最初分配的内存都是一致的，所以开发者尽量不要占用太多的内存空间，没有使用的对象及时置为null。一般情况这种场景是不会出现的，程序员一般只需要关注内存抖动和内存泄露。 内存泄露在Android手机上，内存是很珍贵的，系统为每个应用分配了固定的内存大小，如果申请不到足够的内存空间，就直接导致内存溢出。以前并没有内存泄露的概念，单纯的以为JVM会管理好所有的内存空间，并不需要开发者操心，但事实上不是。内存泄露的根本原因是一个长生命周期的对象持有了一个短生命周期的对象的引用。下面我们来看下Android上面的有哪些内存泄露的风险。 单例模式导致内存泄露，静态对象的生命周期和应用程序一样长，如果持有一个短生命周期如Activity的context就会导致activity无法被回收，所以应该使用getApplicationContext()进行初始化。 内部Handler如果持有了Activity的强引用，而handler执行没有完成，activity就已经调用onDestory了，就会导致activity无法被回收。 非静态内部类默认持有外部类对象引用。所以导致外部类销毁时仍然持有外部类引用，导致外部类无法被回收。 未去注册，如广播，服务，注册或者启动之后必须要去注册 资源对象未及时释放，如Cursor、Stream、Socket，Bitmap等在使用后要及时关闭。 集合中的对象要及时clear。 Android Studio会对代码中可能出现内存泄露的地方会给出提示，能够避免很多常见的内存泄露。对于第二种情况的内存泄露，我们一般是使用静态内部类+弱引用的方式去解决，handler不持有activity引用，而是通过弱引用去获得一个弱引用对象。第三种情况有很多例子场景：1234567891011121314151617181920212223242526272829//线程匿名内部类new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... params) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125;.execute();//线程写成静态内部类private static class MyThread implements Runnable &#123; public void run() &#123; SystemClock.sleep(20000); &#125;&#125; 总结Android关于内存的最佳实践 Enum非常占用内存，因为枚举类型的每个属性值都是Object，每声明一个值都会创建内存以便能引用到这个对象，Android中使用@IntDef、@StringDef来替代枚举类型的使用123Java 的 Enum 的实质是特殊单例的静态成员变量Enum 可以在编写器，编译器做到各种静态检查防呆Enum 在运行期，所有枚举类作为单例，全部加载到内存中 内存泄露是非常容易出现的，上面只是一些大多数场景，还有很多需要注意的地方，特别是一些框架、组件这样的内存泄露很容易忽视。查找内存泄露的方式也很多，如LeakCanary，还有Android Studio3.0自带的Android Profiler，熟练使用这些工具能够快速的帮助自己定位内存泄露，提高程序的性能。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android有哪些处理耗时任务的方式]]></title>
    <url>%2F2019%2F05%2F09%2FandroidThread%2F</url>
    <content type="text"><![CDATA[1、IntentServiceIntentService是继承并处理异步请求的一个类，在IntentService中有一个工作线程来处理耗时操作，启动方法和常规Service一样，不同的是它不需要我们手动控制或销毁，而且IntentService可以启动多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行，必须等待前一个执行完成后才会执行下一个。看源码IntentService实际上就是内部实现了一个Handler，我们知道每启动一次service，如果这个service已经存在就会调用onStartCommand，否则就先执行onCreate方法，在onStartCommand方法中默认会调用onStart方法，IntentService的onStart方法源码如下：123456public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; 可以看到在这个方法中会向自己的handler提交一条消息，然后我们看它的handler源码的handleMessage方法：1234public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; 我们可以看到会调用onHandleIntent，然后执行完之后自动调用stopself。这就是我们使用IntentService默认必须实现它的onHandleIntent方法，而且它执行完成后会自动销毁的原因了。 2、Activity中的runOnUiThread（Runnable runnable）runOnUiThread是Activity中独有的方法，可以实现与UI主线程的通信，那它是怎么通信的呢？首先看这个方法的源码：1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 这段代码什么意思呢？就是当前的线程如果不是UI线程，就向handler提交一个任务，否则就直接调用run方法。所以这个方法就是在activity开启耗时线程执行完成后去提交UI修改。 3、View.post或postDelayed这个方法也是和runOnUiThread类似的，可以实现与UI主线程的通信，不同的是它提交到的是HandlerActionQueue去解决，而且它可以延时执行。 4、AsyncTaskAsyncTask顾名思义就是Android的异步任务，同样在异步任务中也可以执行耗时操作并更新UI，用过异步任务的都知道AsyncTask是一个抽象类，使用它必须继承它并重写它的方法，必须实现它的doInBackground方法，但是一般情况下我们都需要使用它提供的更多的功能，也就是继承AsyncTask&lt;Params,Progress,Result&gt;。这里面三个参数代表什么意思呢？第一个Params表示启动任务时你需要携带给它的参数类型，也就是调用execute方法向里面传递的参数，后面讨论它传递到哪里去了，第二个Progress表示后台任务执行中返回进度值的类型，第三个Result表示后台任务执行完成后返回结果的类型。 我们一般会重写以下4个方法： doInBackground：必须重写的方法，异步执行后台线程要完成的任务,耗时操作将在此方法中完成 onPreExecute:执行后台耗时操作前被调用,通常用于进行初始化操作. onPostExecute:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新. onProgressUpdate:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度.这4个方法的调用顺序是怎样的呢？我们从调用execute方法开始看：1234567891011121314151617181920212223@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; ... mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125;private final WorkerRunnable&lt;Params, Result&gt; mWorker;private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams;&#125;private final FutureTask&lt;Result&gt; mFuture; 我们可以看到首先是onPreExecute()最先调用的，所以我们在执行耗时操作前先使用它初始化，然后我们看到它将execute传递进来的params数组赋给了一个数组，mWorker在构造函数中初始化，然后执行exec.execute(mFuture)。1234567891011121314151617181920212223//一个双端队列，存着工作任务final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();Runnable mActive;public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; //从队列中取出下一个任务 protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; 我们看这个execute方法，它的参数是FutureTask类型的Runnable，传入的mFuture会在一个新的工作任务中执行，然后调用scheduleNext()执行下一个任务。所以现在就到了FutureTask.run方法了，mFuture是在谁初始化的呢？mFuture.run方法会调用什么呢？我们从构造函数中可以看到：1234567891011121314151617181920212223242526272829303132333435363738394041//异步任务的构造方法，默认调用public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); //WorkerRunnable的初始化 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; //FutureTask任务的初始化 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; mFuture是mWorker这个参数去初始化的，关于FutureTask的知识可以去看Java并发编程：Callable、Future和FutureTask。所以最终调用的是mWorker的call方法，在call方法里面我们看到它调用了doInBackground(mParams)，而且传入了mParams数组,doInBackground方法的返回值就是Result类型，最后调用postResult(Result result)方法，1234567private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 可以看到这个方法是向它的handler提交了一条消息。我们来看这个handler的消息处理方法:12345678910111213@Overridepublic void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125;&#125; 可以看到它只会处理两种消息，一种是异步任务执行完成，一种是在异步方法执行中调用，那我们接着看：12345678910111213141516@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125;private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 可以看到执行完成后调用的finish方法，如果正常执行完成，调用的是onPostExecute(result)，所以我们说onPostExecute方法执行在doInBackground方法后，我们说在doInBackground方法中调用publishProgress方法，会调用onProgressUpdate方法，也可以从上面的源码中得出结论。 5、HandlerThread一个Android封装的轻量级异步类。知道它的工作原理也就知道了它的优点，它是利用Thread+Handler实现的，它继承自Thread，使用它需要先创建一个HandlerThread实例，紧接着调用start将这个线程启动起来，它的run方法为：123456789101112public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 6、Handler从上面所有的方式中我们都可以看到Handler的身影，所以说学习Android必须先学好Handler。关于Handler的博客就太多了，可以看Android Handler：手把手带你深入分析 Handler机制源码,Android：这是一份Handler消息传递机制 的使用教程,Android Handler：图文解析 Handler通信机制 的工作原理,上面三篇从使用，到原理，到源码由浅入深仔细讲解了Handler机制。 问：在线程中使用Handler时(除了Android主线程)必须把它放在Looper.prepare()和Looper.loop()之间。否则会抛出RuntimeException异常。但是为什么要这么做呢？答：通俗的讲Handler机制就是主线程中有一个无限循环，与UI主线程绑定起来，它会一直循环，拿到一个消息之后就会去主线程中去调用handleMessage方法。其实就是Looper类和Handler类，Looper类封装了消息循环和消息队列，当你调用了Looper.prepare()之后，这个Looper就开始启用了，一般情况主线程在Application初始化的时候就已经自动创建一个Looper，因为一个线程就只能有一个Looper，所以在非主线程中先要调用Looper.prepare()先创建一个Looper。调用Looper.loop()之后就开始了从MessageQueue中取出消息的无限循环。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制]]></title>
    <url>%2F2019%2F04%2F23%2Fandroid%2F</url>
    <content type="text"><![CDATA[View的事件分发机制是解决滑动冲突的基础。首先要理解两个概念，View和ViewGroup，控件如Button，TexiView，ImageView等都继承自View父类，布局如LinerLayout，RelativeLayout等都继承自ViewGroup。那怎么理解这两个东西呢？我们可以将整个Activity页面看做一个容器，所有的控件（View）都装在这个容器（ViewGroup）里。 首先我们先说下结论，Android中Touch事件的传递绝对都是先到ViewGroup，然后在到View，所以无论点击了哪个控件都会先调用所在布局的dispatchTouchEvent方法，如果没有被消费掉就会向下传递到控件的dispatchTouchEvent方法。然后我们看以下三个核心方法： public boolean dispatchTouchEvent(MotionEvent ev)用来进行事件的分发。如果事件能够传递给当前的View，那么这个方法就一定会被调用，返回结果受当前View的onTouchEvent和下级的dispatchTouchEvent方法影响，表示是否消耗当前事件。 public boolean onInterceptTouchEvent(MotionEvent event)在dispatchTouchEvent方法内部调用，这个方法表示是否拦截某个事件，这个方法存在于父级的View中，也就是一般重写在ViewGroup中 public boolean onTouchEvent(MotionEvent event)在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件 用一段伪代码来表示三种方法的关系：123456789public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean comsume = false； if(onInterceptTouchEvent(ev))&#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 当一个，View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。在onTouchEvent方法中，如果当前设置的有onClickListener，那么它的click方法会被调用，可以看出我们平时所用的onClickListener优先级最低，位于末端。当一个点击事件产生后，它的传递过程遵循如下规则：Activity-&gt;Window-&gt;View,这里的View是顶级View，顶级View接收到事件后，会按照事件分发机制一步步向下分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，以此类推。如果所有的元素都不处理这个事件，那么最终这个事件会被传递给Activity处理，调用Activity的onTouchEvent方法。关于事件分发机制，这里有一些结论：（1）同一事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕，事件序列会经历down事件，以及数量不定的move事件，最后以up事件结束；（2）正常情况下，一个事件序列只能被一个View拦截消耗；（3）某个View一旦决定拦截，那么这一个事件序列只能由它自己处理，并且它的onInterceptTouchEvent方法不会再被调用（4）某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列的其他事件都不会再交给它处理，并且事件将重新交由它的父元素去处理，即调用父元素的onTouchEvent。（5）如果View不消耗除了ACTION_DOWN的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续事件。并且这些消失的点击事件会交给Activity处理。（6）ViewGroup默认不会拦截任何事件。（7）View没有onInterceptTouchEvent方法，一旦有事件传递给它就会调用它的onTouchEvent方法。（8）View的onTouchEvent默认都会消耗事件，除非它是不可点击的（clickable和longClickable同时为false，View的longClickable默认为false）。（9）View的enable属性不影响onTouchEvent的默认返回值。（10）onClick会发生的前提是当前View是可点击的，并且它收到了down和up事件。（11）事件传递过程都是由外向内的，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。mInputEventConsistencyVerifier变量是调试用的，不用理会。onFilterTouchEventForSecurity()表示是否要分发该触摸事件，具体可以看里面的源码，主要看是否该View是否被屏蔽了。intercepted变量标志Group是否拦截Touch事件的传递，会调用ViewGroup的onInterceptTouchEvent方法进行判定。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM日记(一)]]></title>
    <url>%2F2019%2F04%2F17%2FJVM1%2F</url>
    <content type="text"><![CDATA[Java虚拟机第一篇熟读《深入理解java虚拟机》，将自己的所学所感记录下来 运行时数据区根据java虚拟机规范，JVM在执行程序时会将它所管理的内存划分为5大块数据区域，分为叫做方法区，堆，虚拟机栈，本地方法栈，程序计数器。方法区和堆都是所有线程共享的数据区，其余是线程隔离的数据区 1.虚拟机栈和本地方法栈虚拟机栈是线程隔离的数据区，理所当然它的生命周期随着线程的创建而产生，线程的销毁而终止。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧(stackframe)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到完成就是一个栈帧在虚拟机栈中入栈到出栈的过程。 大多数程序员所认知的堆和栈就是JVM的全部，而所指的栈就是虚拟机栈了，或者可以说是虚拟机栈的局部变量表部分。局部变量表存放了编译器可知的各种数据类型（java的8大基本数据类型），对象引用类型（它不等同于对象本身，可能是一个指向对象的指针或者是指向一个代表对象的句柄或其他于此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用两个局部变量空间，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成匹配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在java虚拟机规范中，对这个区域定义了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展,且扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈和虚拟机栈所发挥的作用是非常相似的，他们之间的区别是本地方法栈是为native方法服务的。 2.程序计数器程序计数器是一块较小的内存空间，由线程自身维护，我们可以将它看作是当前线程所执行的字节码的行号指示器。由于Java的多线程实际上是由线程轮流切换并分配处理器时间片来实现的，只是切换很快就让人以为是并发的。因此，为了线程切换后能够回到原来的位置，每条线程都需要有一个独立的程序计数器。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器值则为空。此内存区域是java虚拟机规范中唯一一个不会存在OutOfMemoryError。 3.Java堆Java堆的唯一目的是分配对象实例，几乎所有的对象实例都在这里分配内存，java规范的定义是：所有对象实例和数组都在堆上分配内存，但是随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些变化。 4.方法区方法区存放的是已被虚拟机加载的类信息，常量，静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做非堆，目的是与堆区分开来。对于习惯在Hotspot虚拟机上开发、部署程序的人来说，很多人愿意把方法区称为“永久代”，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已，便于HotSpot收集器管理这部分内存。 5.运行时常量池运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池对于Class文件常量池的另一个重要特性是具备动态特性，Java语言并不要求常量只会在编译期生成，也就是并非预置入Class文件中常量池的内容才能进入方法区常量池，运行期间的例子就是String的intern()方法 6.直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分的频繁使用也会导致OutOfMemoryError。在jdk1.4中加入了NIO（NewInput/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场合中显著提升性能，因为避免了在Java堆和Native堆中来回复制数据。 垃圾收集怎样判断对象已死，回收它的内存？ 1.引用计数算法给对象添加一个引用计数器，当有一个引用时+1，引用失效就-1.优点：实现简单，判断效率高，在大部分情况下是一个不错的算法，著名的应用案列有微软公司的COM技术，Python语言，使用ActionScript3的FlashPlayer等。缺点：很难解决对象的相互循环引用问题。 2.可达性分析算法基本思路：通过一系列的称为“GCRoots”的对象作为起始点，从这些节点往下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象无用。在Java语言中，可作为GC Roots的对象包括下面几种：1）、虚拟机栈中引用的对象2）方法区中类静态变量属性引用的对象3）方法区中常量的引用对象4）本地方法栈中JNI引用的对象 3.再谈引用无论是那种算法判断存活都与“引用”相关，所以为了将引用定义的更加清晰，以便于内存空间的管理，Java将引用定义了4种，强应用，软引用，弱引用，虚引用。这4种引用强度依次减弱 强应用(Strong Reference) 软引用(Soft Reference) 弱引用(Weak Reference) 虚引用(Phantom Reference) 强引用强应用就是代码中普遍存在的写法。 1Object o = new Object(); 软引用软引用就是用来描述一些还有用但并非必须的对象，在内存不足的情况下它才会被回收，Java提供了SoftReference类来实现软引用 123Object o = new Object();SoftReference&lt;Object&gt; sr = new SoftReference&lt;&gt;(o);Object object = sr.get(); 弱引用弱引用也是用来描述非必须对象的，它的引用强度更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，Java提供了WeakReference类来实现弱引用。使用方法和软引用一致。 虚引用它是最弱的一种引用，它的存在不会影响对象的回收，也无法使用它来获取对象的实例，它存在的唯一目的是在与它关联的对象实例被回收的时候收到一个系统通知 回收方法区永久代的垃圾回收主要有两个方面：废弃常量和无用的类。 废弃常量以常量池的字面量为例，假如&quot;abc&quot;字符串已经存在于常量池了，但是在当前系统中没有一个地方引用了这个常量，如果发生内存回收且有必要的话他就会被回收。 无用的类判断无用的类要同时满足以下3个条件 该类所有的实例都已经被回收，也就是Java堆中不存在该类的实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。满足这些条件就有可能被虚拟机回收。 Java分代收集1.Java年轻代和年老代 年轻代分为一个Eden区和两个survivor区（分别叫做from和to），比例一般为Eden：survivor=8:1，新new的对象都是分配在Eden区中（一些大对象特殊处理），经过第一次GC过后，如果对象依然被引用，那么就会移动到survivor区，对象在survivor区每多熬过一次MonitorGC，年龄就会增加一岁，当年龄达到一定时，会被移动到年老代中（Old区）。年轻代的对象大部分都是朝生夕死的，所以GC采用的是复制算法，复制算法就是将内存分为两块，一块用完了就将活着的对象移到另一块上面去，好处是不会产生内存碎片，缺点是会造成一半的内存浪费。 年老代：Old区当年老代被塞满之后就会触发Full GC，非常耗时，Old区GC算法为标记-清除或者标记-整理算法。标记-清除算法就是将内存还存活的对象标记，然后清除没有标记的对象，它存在两个问题，一是效率问题，标记和清除效率都不高，而是空间问题，清除之后会造成大量的空间碎片，就使得如果有比较大的对象没有连续空间分配就会再次触发GC。标记-整理算法和标记-清除算法的不同就是，所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 堆中分配很大的对象所谓大对象，是指需要大量连续内存空间的Java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的FullGC后,跟着来一次带压缩的 System.gc()方法的调用此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数中1出现的次数]]></title>
    <url>%2F2018%2F04%2F17%2FtimesOfInteger%2F</url>
    <content type="text"><![CDATA[求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数 思路按照数学的排列组合思路来解，数字1位于不同的位置，共有多少种排列，包括重复的排列。1、首先拿到一个整数，有m位，数字首位为s，则0~99..99（m-1个9）这个区间1出现的次数是sum=(m-1)*10^(m-2)（1的重复排列）；2、接下来count=s*sum(以2345为例，m为4，0~999区间1出现的次数为1的重复排列3*10*10=300，count=2*300=600)，统计的是后m-1位中1的重复排列与首位排列相乘；3、后面如果首位s大于1，就加上10^(m-1)(以2345例子就加上1000，count=600+1000=1600)； s等于1，就加上划去首位1的数再加上1（以1345例子看就是345+1，count+=346）4、接下来就是递归了，我就不赘述了，看代码。详细代码 12345678910111213141516171819202122232425262728import java.util.HashMap;import java.util.Map;public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; if(n==0) return 0; else if(n&lt;10) return 1; int count = 0; int length = test(n)-1;//长度减一 int divisor = (int) Math.pow(10,length);//除数 int y = n%divisor;//余数 int l = n/divisor;//数字首位 int sum = (int)(length*Math.pow(10,length-1)); count = l*sum; if(l&gt;1) count+=divisor; else if(l==1) count=count+y+1; return count+NumberOf1Between1AndN_Solution(y); &#125; public int test(int n)&#123; String str = String.valueOf(n); char[]chars = str.toCharArray(); return chars.length; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之NexT主题搭建博客踩过的坑]]></title>
    <url>%2F2018%2F04%2F01%2Fnext%2F</url>
    <content type="text"><![CDATA[hexo+github搭建博客，自己也是拾前人牙慧，花了一天时间解决各种问题，本来很简单的问题也是在摸索中花费了大量时间，想起来就很搞笑，不过到底是解决了，好了，想要去看比较详细的过程就去: VOLC这个博客吧，写的够详细了，下面写我踩过的坑吧。 遇到的问题1.图标问题新版的hexo不需要在menu_icons中用key-value方式为menu添加图标，在菜单项menu（名称和链接）加 || FontAwesome icon的name 123456789101112menu: home: / ||home categories: /categories ||th archives: /archives ||archive tags: /tags ||tags message: /message ||external-link about: /about ||user #commonweal: /404.html# Enable/Disable menu icons.menu_icons: enable: true 2.头像问题在blog/source文件夹下新建img文件夹，将你的头像图片放进去，在站点文件_config.yml中修改 12# 设置头像avatar: img/hg.jpeg 3.在博文中添加图片1.把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true2.在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件3 最后在xxxx.md中想引入图片时，先把图片复制到source/_posts/xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) 4.本地项目托管到github首先在你的github中new一个新的代码仓库，name：{your blog’s name}.github.io 修改站点文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:tomycatbaby/tomycatbaby.github.io.git branch: master 验证是否能否连接到github1$ ssh -T git@github.com 成功后1Hi zhangsan! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 上传代码 中间会输入github密码 1hexo -d 成功后就可以用 http://tomycatbaby.github.io 访问了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
